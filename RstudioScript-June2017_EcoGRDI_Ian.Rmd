# Installing the required packages for R:
# This is to be done in the R command line and not in R studio
#source("https://www.Bioconductor.org/biocLite.R")
#biocLite("BiocUpgrade")


Getting started in R: Set the working directory > setwd("~/") Check version installed
```{r global_options, include=FALSE}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60), tidy = TRUE, fig.align='center')
```


This will help us when finding our files to source functions:
```{r sourcing_my_functions}
install.packages("rprojroot")
library(rprojroot)
# We specify ours is an RStudio project
# The root object contains a function that will help us locate our package r files
# regarless of our current working directory
root <- rprojroot::is_rstudio_project
scriptsPath <- root$make_fix_file(".")("R")
scripts  <- dir(root$find_file("R", path = root$find_file()))
scriptsl <- paste(scriptsPath, scripts, sep = "//")
lapply(scriptsl, source)
```

User: 
Define the path to the shared folder where the main working directory will be.
```{r setting_the_main_directory, cache=TRUE}
sharedPath <- "/fs/hnas1-evs1/Dgrdi/grdi_eco/groups/bilodeaug/gir001/PIRL_working/"
```

User:
Specify the name and path of the csv file you would like to use for generation of the 
metadata file if not using the csv file generated by sequencing service:
*Note: I suggest saving the file in the references folder in the shared path. Getting more specific
and making a directory just for these tables is fine too - but the table will be copied to the new
directory for this analysis later in the script. It's just important to have a raw, untouched 
reference for this data kept in a place where you will remember and keep all the other ones you use.
```{r metadata_name_and_path, cache=TRUE}
metadataFileAlternate <- "EcoMetadata_IanRawData_original.csv"
metadataPath <- paste(sharedPath, "References/", metadataFileAlternate, sep = "")
```

User:
Define the the folder in the shared folder that will hold the analyses of the 
time-course/dataset you will be working with. In our case, we have two different 
time-course experiments, Oosporogenesis and Oospore Conversion. Below we set 
which one the script will run analyses for. We also get the user to specify what 
the name of the directory that will hold the reads will be. In the case below, 
we are calling the sequencing data directory (seqDataDir) "MiSeq_data_Sci2" 
because sequencing of oospore conversion time-course reads was done on the 
in-house MiSeq and was the second run we had done on this instrument for the 
overall project. We also added Sci2 because the sequencing libraries were made 
on the SciClone robotics instrument, and also represent the second time we 
generated libraries on that instrument:
```{r analysis_and_sequence_directory, cache=TRUE}
analysis   <- "ecoBiomics_Ian/"
seqDataDir <- "sequencingData"
```

User needs to specify the adapter sequences attached to the sequencing 
reads. This will depend on how the libraries were prepared. Specify which sequencing platform was 
used to generate the reads: 
1 - MiSeq
2 - HiSeq
3 - Ion Torrent

Also specify the library layout - paired-end or single reads (Illumina only):
1 - single
2 - paired-end
```{r sequencing_platform_used, cache=TRUE}
platform      <- 1
libraryLayout <- 2
```

User:
Specify the read-processing and quality assessment tool to be used.
1 - FastQC
2 - PrinSeq
```{r read_processing_tool, cache = TRUE}
readProc <- 2
```

User:
Specify which tool to use for assembly:
1 - Newbler (for 454 and Ion Torrent reads)
2 - SPADES (for Illumina reads, mainly)
```{r assembler, cache = TRUE}
# assembler <- 2 # Given ecobiomics data here is not whole-genome, but amplicons.
```

User:
The following paths are to directories where the references, tools and general 
requirements are located, this depends on the directories actually having been 
put there:
```{r user_tools_and_references_dir, cache=TRUE}
toolsDirPath     <- paste(sharedPath, "tools/", sep = "")
referencesPath   <- paste(sharedPath, "References/", sep = "")
fastqPEValidatorPath <- paste(toolsDirPath, "FastqPairedEndValidator.pl", sep = "")
```

We prepared our libraries using the Mondrian and SciClone with library 
kits, instruments and kits by NuGen. NuGen kits are designed to work with 
Illumina sequencing platforms and generate libraries with the sequence 
structure:

5' AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT 
   (N) 
   AGATCGGAAGAGCACACGTCTGAACTCCAGTCAC <- region to select as forward adapter
   XXXXXX 
   ATCTCGTATGCCGTCTTCTGCTTG 3'
   
3' TTACTATGCCGCTGGTGGCTCTAGATGTGAGAAAGGGATGTGCTGCGAGAAGGCTAGA 
   (N) 
   TCTAGCCTTCTCGTGTGCAGACTTGAGGTCAGTG <- region to select as reverse adapter
   XXXXXX 
   TAGAGCATACGGCAGAAGACGAAC 5'

Where each string of ‘X’ is the unique 4-, 6, or 8-base barcode from the 
L2 adaptor mix of the library construction system (where applicable) 
and (N) is the library insert.

We will need to remove any adapter sequences from our reads. We will
be doing this with SeqPrep. SeqPrep specifies that the user must first 
ensure the adapter sequences they choose are correct by doing a "grep"
on the reads first:

Before running SeqPrep make sure to check that the program's defaults 
are indeed the adapters you are looking for. Try copying the default 
forward adapter from this file and grep it against your reads doing a 
word count, also try the same with the reverse adapter with grep. You 
should see some hits. You can also try using (and validating with grep) 
-A GATCGGAAGAGCACACG -B AGATCGGAAGAGCGTCGT as parameters. To find a 
list of Illumina adapter sequences you should write to Illumina tech 
support TechSupport@illumina.com (they do not like people to share the 
list of sequences outside of their institution).

Chose about 20bp of an adapter sequence where:
1. You see the most hits with grep
2. When you run a command like:
   cat Lane2_0d_2.fastq | head -n 1000000 | grep "INSERT ADAPTER HERE" | head 
   you see the adapter sequence show up at the beginning of a few reads. 
   Also the -A and -B arguments should be as they show up in your data, 
   SeqPrep searches directly for these sequences without doing reverse 
   complementing.
3. Check the forward and reverse and make sure that you have roughly the 
   same number of hits via a command to count hits like: 
   cat Lane2_0d_2.fastq | head -n 1000000 | grep "INSERT ADAPTER HERE" | wc -l
```{r setting_seq_adapters_based_on_platform, cache=TRUE}
fwdAdapHiSeq    <- "AGATCGGAAGAGCACACGTCTGAACTCCAGTCA"  # HiSeq, Genome Quebec
revAdapHiSeq    <- "AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT"  # HiSeq, Genome Quebec

# Notice that the adapter sequences we chose when processing the MiSeq reads
# is from the same region we are choosing for our HiSeq reads, only shorter:
fwdAdapMiSeq <- "AGATCGGAAGAGCACAC"   # MiSeq
revAdapMiSeq <- "AGATCGGAAGAGCGTCGT"  # MiSeq

fwdAdapIonT  <- "CCATCTCATCCCTGCGTGTCTCCGACTCAG" # "A" adapter sequence for IonTorrent
revAdapIonT  <- "CCTCTCTATGGGCAGTCGGTGAT"        # "trP1" adapter sequence for IonTorrent

if(platform == 1){
    fwdAdap <- fwdAdapMiSeq
    revAdap <- revAdapMiSeq
    print('Your sequencing platform was set to the Illumina MiSeq')} else if 
(platform == 2){
    fwdAdap <- fwdAdapHiSeq
    revAdap <- revAdapHiSeq
    print('Your sequencing platform was set to the Illumina HiSeq')} else if
(platform == 3){
    fwdAdap <- fwdAdapIonT
    revAdap <- revAdapIonT
    print('Your sequencing platform was set to the Ion Torrent')} else {
        rm(fwdAdap, revAdap)
        print('You either didn\'t specify a valid sequence platform, or none was provided')
    }
fwdAdap
revAdap
```

The user does not alter the variables below. 
```{r settingToQsubWithinRStudio, cache=TRUE}
# Sys.setenv(PATH=paste('/opt/gridengine/bin/linux-x64',Sys.getenv('PATH'),sep= ':'))
```


The following chunk will integrate the user-defined variables from the previous chunk into the script.
```{r creating_dir_for_analysis, cache=TRUE}
# Create the analysis directory:
dir.create(paste(sharedPath, analysis, sep = ""), 
           showWarnings = TRUE, 
           recursive    = FALSE)

# Set the path to the analysis directory:
sharedPathAn <- paste(sharedPath, analysis, sep="")

# Create fastq directory in sharedPath folder based on "seqDataDir":
dir.create(paste(sharedPathAn, seqDataDir, sep = ""), 
           showWarnings = TRUE, 
           recursive    = FALSE)

# Set the path the fastq directory:
pathFastq <- paste(sharedPathAn, seqDataDir, "/", sep = "")
```

Path to the biocluster-installed tools:
```{r biocluster_tools_paths, cache=TRUE}
# tophat2Path      <- "/opt/bio/tophat/bin/tophat2"
# bowtie2BuildPath <- "/opt/bio/bowtie2/bowtie2-build"
# starPath         <- "/opt/bio/STAR/STAR"
# htseqCountPath   <- "/opt/bio/HTSeq/bin/htseq-count"
prinSeqPath      <- "/opt/bio/prinseq-lite/prinseq-lite"
prinSeqGraphPath <- "/opt/bio/prinseq-lite/prinseq-graphs"
# samtools1Path    <- "/opt/bio/samtools1/bin/samtools1"
seqPrepPath      <- "/opt/bio/SeqPrep/SeqPrep"
trimmomaticPath  <- "/fs/hnas1-evs1/Dgrdi/grdi_eco/groups/bilodeaug/gir001/.conda/envs/mpienv/bin/trimmomatic"
fastq2faPath    <- "/fs/hnas1-evs1/Dgrdi/grdi_eco/groups/bilodeaug/gir001/.conda/envs/mpienv/bin/fastqToFa"
```

Bowtie:
Creating Bowtie reference index from the fasta file: Not done for Lachnellula willkommii
```{r bowind eval = FALSE, echo = FALSE, include = FALSE, cache=TRUE}
# bowind <- "lachwiiRef"
# 
# cmd    <- paste(bowtie2BuildPath, 
#                 " -f ", pyuuRefPath,
#                 " ", paste(referencesPath, bowind, sep = ""),
#                 sep = "")
# cmd
# #system(cmd)
```

Below the metadata file specified by the user is copied into the analysis folder and read into R:
```{r copy_metadata_to_analysis_dir_and_read, cache=TRUE}
cmd      <- paste("cp ", metadataPath, " ", sharedPathAn, sep = "")
system(cmd)
metadata <-  read.table(paste(sharedPathAn, metadataFileAlternate, sep = ""),
                        sep          = ",",
                        header       = TRUE,
                        comment.char = "", 
                        quote        = "",
                        as.is        = TRUE)
if(libraryLayout == 2){
    metadata$BaseCallsName <- paste(metadata$LibraryName, "_", 
                                    metadata$ReadDirection, ".fastq", sep = "")
} else if
(libraryLayout != 2){
    metadata$BaseCallsName <- paste(metadata$LibraryName, ".fastq", sep = "")
}
```

This function will delete qsub temp files that are the sub.e* outputs (error outputs)
```{r}
# X <- function(path, prefixSub) {
#   system(paste("find ", path, prefixSub, "/", prefixSub, "*", ".sub.e", "*", " -delete ", sep = ""))
# }
```

Copy and gunzip files:
```{r copyRaw_gunzip, cache=TRUE}
# Copy all files using multiple processors (this is a lot faster than the above)
# cmd <- with(metadata, paste("cp ", 
#                 FastqFilePath," ", 
#                 sharedPathAn, seqDataDir, "/", basename(FastqFilePath),"\n",
#                 " gunzip ", 
#                 sharedPathAn, seqDataDir, "/", basename(metadata$FastqFilePath),
#                 sep=""))
# OR

#If you want to rename the files that you are copying over, do the following.
#It is based on what you put under BaseCallsName in your adapted metadata csv.
cmd <- with(metadata, paste("cp ", 
                RawSeqPath," ", 
                sharedPathAn, seqDataDir, "/", metadata$BaseCallsName, ".gz","\n",
                " gunzip ", 
                sharedPathAn, seqDataDir, "/", metadata$BaseCallsName, ".gz",
                sep=""))

# Generate qsub and bash files to complete the commands above:
prefix <- "A_copy_unzip" 
suffix <- ".sub"
# Must do the following instead of bash name.sh file, since qsub doesn't work on the gpsc:
# $ chmod u+x *
# $ for subfile in *.sub; do ./$subfile; done 2>&1 | tee pairedEndVal.log

MakeQsubs(cmd, prefix, suffix)
```

Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

Add the name of the raw fastq files to the metadata table
```{r, cache=TRUE}
if(libraryLayout == 2){
    for(k in 1:nrow(metadata)){
        metadata$RawFastq <- paste(metadata$LibraryName, "_", 
                                   metadata$ReadDirection, ".fastq", sep = "")}
    } else if
(libraryLayout != 2){
    for(k in 1:nrow(metadata)){
        metadata$RawFastq <- paste(metadata$LibraryName, ".fastq", sep = "")
    }
}
```
The following will create a metadata table based on the library layout - paired-end or single reads.
Read pairs will be collapsed to one row per pair.
```{r, cache=TRUE}
library("reshape2")
if(libraryLayout == 2){
    metadataRawPairs <- dcast(data = metadata, LibraryName 
                              ~ ReadDirection, value.var = "BaseCallsName", FUN = c)
    metadataRawPairs$ShortName <- paste(metadataRawPairs$LibraryName)
    metadataRaw <- metadataRawPairs} else if
(libraryLayout != 2){
    metadata$ShortName <- paste(metadata$LibraryName)
    metadataRaw <- metadata} else {
        cat(c("Error: Either an incorrect number was entered for library", "\n",
              "layout (single reads = 1 and paired-end reads = 2), or no selection was", "\n",
              "specified. The default will be to consider reads single.", sep = ""))
        metadata$ShortName <- paste(metadata$LibraryName)
        metadataRaw <- metadata
        }
# We can get more specific if we want, such as when there are many samples and/or a time-course:

# metadataRawPairs$ShortName <- paste(metadataRawPairs$Condition, 
#                                     metadataRawPairs$TimePoint, 
#                                     metadataRawPairs$RNASeq_Replicate, sep = ".")
```

Looking at our raw data:
Ensure that if reads are paired-end, that they are correctly paired and ordered between read 1 and
read 2 fastq files.
```{r, cache=TRUE}
# Run FastqPairedEndValidator for the first time on the raw read pairs:
if(libraryLayout == 2){
    prefix <- "B_Validator"
    cmd <-  with (metadataRaw, paste(fastqPEValidatorPath,
                                     " ", pathFastq, R1, " ", pathFastq, R2, sep = ""))
    suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)} else if
(libraryLayout != 2){
        cat(c("Fastq pairend end validator will not be used because you did not specify that", "\n",
              "your reads are paired end", sep = ""))
        }
#system("qstat")
```

If reads were paired-end, and the Fastq Paired-End validator was run, the output of each pair will
be displayed on the console:
```{r, echo=FALSE, cache=TRUE}
if(libraryLayout == 2){
    for (k in 1:nrow(metadataRaw)) {
        cat(c(k, metadataRaw$R1[k], metadataRaw$R2[k]))
        system(paste("cat ", sharedPathAn, prefix, "/", prefix, k, suffix, ".o*", sep = ""))
        cat("\n")}} else if
(libraryLayout != 2){
    cat(c("The fastq pairend end validator was not used because you specified that your", "\n",
              "reads are not paired end", sep = ""))
        }
```
To remove the output files after you are done:
```{r, echo=FALSE, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

Note - for this data set, there is no point to running the graph 
Look at the raw fastq graphs prior to adapter removal, QA, and other processing
using PrinSeq graph reports of raw reads, 
Step 1: .gd file generation:
```{r, echo=FALSE, cache=TRUE}
prefix <- "C_PrinSeq_rawGraphs"
if(libraryLayout == 2){
    cmd <- MakePrinSeqGraphFiles(metadataRaw, metadataRaw$R1, prefix,
                                 "rawGraphs", metadataRaw$R2)
    suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)} else if
(libraryLayout != 2){
    cmd <- MakePrinSeqGraphFiles(metadataRaw, metadataRaw$RawFastq, prefix, "rawGraphs")
    suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
}
```

Add the name of the raw graphs .gd files to the 
metadata table:
```{r echo = FALSE, cache=TRUE}
for(k in 1:nrow(metadataRaw)){
  metadataRaw$RawGraphName <- paste(metadataRaw$LibraryName, ".rawGraphs.gd", sep = "") 
}
```

You can follow the progress of the PrinSeq graph generation run with the following:
```{r, echo=FALSE, cache=TRUE}
for(k in 1:nrow(metadataRaw)){
    cat(c(k, metadataRaw$LibraryName[k]))
    cat("\n")
    system(paste("cat ", sharedPathAn, prefix, "/", prefix, k, suffix, ".e*", sep = ""))
    cat("\n")}
```

Adapter removal:
```{r}
prefix <- "D_SeqPrep_adapter_Removal"
if(libraryLayout == 2){
    cmd <- with(metadataRaw, 
            paste(seqPrepPath, 
                  " -f ", pathFastq, R1,
                  " -r ", pathFastq, R2,
                  " -1 ", pathFastq, LibraryName, ".adapRem.R1.fastq.gz",
                  " -2 ", pathFastq, LibraryName, ".adapRem.R2.fastq.gz",
                  " -A ", fwdAdap,
                  " -B ", revAdap,
                  " -s ", pathFastq, paste(LibraryName, ".adapRemMerged.fastq.gz", sep = ""),
                  sep = ""))} else if 
(libraryLayout != 2){
    cmd <- with(metadataRaw, 
            paste(seqPrepPath, 
                  " -f ", pathFastq, RawFastq,
                  " -1 ", pathFastq, LibraryName, ".adapRem.fastq.gz",
                  " -A ", fwdAdap,
                  sep = ""))
}
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

cmd[1]
```

To show the output of each pair on the console in Rstudio:
```{r}
if(libraryLayout == 2){
    for(k in 1:nrow(metadataRaw)) {
      cat(c(k, metadataRaw$R1[k], metadataRaw$R2[k]))
      cat("\n")
      system(paste("tail ", sharedPathAn, prefix, "/", prefix, k, suffix, ".e* | head -n 10" , sep=""))
      cat("\n")
    }
    } else if
(libraryLayout != 2){
    for(k in 1:nrow(metadataRaw)) {
      cat(c(k, metadataRaw$RawFastq[k]))
      cat("\n")
      system(paste("tail ", sharedPathAn, prefix, "/", prefix, k, suffix, ".e* | head -n 10" , sep=""))
      cat("\n")
    }
}
```

To remove the output files after you are done:
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

```{r}
library("reshape2")
metadataAdapRM <- dcast(data = metadata, LibraryName + Region + Sample + Provider + Experiment + ExtractionKit + AdapRemMerged
                        ~ ReadDirection, value.var = "BaseCallsName", FUN = c)
metadataAdapRM$ShortName <- paste(metadataAdapRM$LibraryName, sep = ".")
colnames(metadataAdapRM)[colnames(metadataAdapRM) == "AdapRemMerged"] <- "MergedReads"
```


Using trimmomatic:
```{r}
trimmomaticPath  <- "/fs/hnas1-evs1/Dgrdi/grdi_eco/groups/bilodeaug/gir001/.conda/envs/mpienv/bin/trimmomatic"
cmd <- paste(trimmomaticPath, " --help", sep = "")
system(cmd)
```
Trimmomatic variables:
```{r}
prefix <- "E_Trimmomatic"
headcrop      <- "10"
slidingwindow <- "4:20"
minlen        <- "36"
leading       <- "0"
trailing      <- "0"
crop          <- "1000"
avgqual       <- "0"
illuminaclip  <- "null.fa:0:0:0"
cmd <- with(metadataAdapRM,
            paste(trimmomaticPath, " SE ",
                  " ", paste(pathFastq, MergedReads, ".gz", sep = ""),
                  " ", paste(pathFastq, LibraryName, ".adapRemMerged_trimmomatic.fastq.gz", sep = ""),
                  " -phred33 ",
                  " -trimlog ", paste(LibraryName, ".log", sep = ""),
                  " -summary ", paste(LibraryName, ".stat", sep = ""),
                  " HEADCROP:", headcrop,
                  " SLIDINGWINDOW:", slidingwindow,
                  " MINLEN:", minlen,
                  " LEADING:", leading,
                  " TRAILING:", trailing,
                  " CROP:", crop,
                  " AVGQUAL:", avgqual,
                  #" ILLUMINACLIP:", illuminaclip,
                  sep = ""))
cmd[1]
suffix <- ".sub"
MakeQsubs(cmd, prefix, suffix)
# $ parallel ::: ./*sub 2>&1 | tee maker.log
```

Record the trimmed output in the metadata tablee:
```{r}
metadataAdapRM$mergedTrimmo <- paste(metadataAdapRM$LibraryName, ".adapRemMerged_trimmomatic.fastq.gz", sep = "")
```

Convert fastq to fasta, as per SnakeMake pipeline:
```{r}
fastq2faPath    <- "/fs/hnas1-evs1/Dgrdi/grdi_eco/groups/bilodeaug/gir001/.conda/envs/mpienv/bin/fastqToFa"
cmd <- paste(fastq2faPath, sep = "")
system(cmd)

prefix <- "F_fastq2fasta"

cmd <- with(metadataAdapRM,
            paste("gunzip ", paste(pathFastq, mergedTrimmo, sep = ""), "\n",
                  " ", fastq2faPath, " -verbose=2 ",
                  " ", paste(pathFastq, LibraryName, ".adapRemMerged_trimmomatic.fastq", sep = ""),
                  " ", paste(pathFastq, LibraryName, ".adapRemMerged_trimmomatic.fasta", sep = ""),
                  sep = ""))
cmd[1]
suffix <- ".sub"
MakeQsubs(cmd, prefix, suffix)
```

