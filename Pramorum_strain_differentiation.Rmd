---
title: "Phytophthora ramorum strain delimitation"
author: "Emily Giroux"
date: "10/24/2018"
output: html_document
---
# Installing the required packages for R:
# This is to be done in the R command line and not in R studio
#source("https://www.Bioconductor.org/biocLite.R")
#biocLite("BiocUpgrade")


Getting started in R: Set the working directory > setwd("~/") Check version installed
```{r global_options, include=FALSE}
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=60), tidy = TRUE, fig.align='center')
```


This will help us when finding our files to source functions:
```{r sourcing_my_functions}
install.packages("rprojroot")
library(rprojroot)
# We specify ours is an RStudio project
# The root object contains a function that will help us locate our package r files
# regarless of our current working directory
root <- rprojroot::is_rstudio_project
scriptsPath <- root$make_fix_file(".")("R")
scripts  <- dir(root$find_file("R", path = root$find_file()))
scriptsl <- paste(scriptsPath, scripts, sep = "//")
lapply(scriptsl, source)
```

User: 
Define the path to the shared folder where the main working directory will be and define the folder
in the shared folder that will hold the analysis dataset you will be working with.
```{r setting_the_main_directory, cache=TRUE}
sharedPath <- "/isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/"
analysis   <- "pramorum_strain_differentiation/"
seqDataDir <- "data"
```

User:
The following paths are to directories where the references, tools and general 
requirements are located, this depends on the directories actually having been 
put there:
```{r user_tools_and_references_dir, cache=TRUE}
referencesPath   <- paste(sharedPath, "References/", sep = "")
```

User:
Specify the name and path of the csv file you would like to use for generation of the 
metadata file:
This file should have all the rad processing information.
```{r metadata_name_and_path, cache=TRUE}
metadataFileAlternate <- "fus_phra_metadata_processed_june2018.csv"
metadataPath <- paste(sharedPath, "References/", metadataFileAlternate, sep = "")
metadataAssembliesFile <- "fus_phra_metadata_Assembly_june2018.csv"
metadataAssembliesPath <- paste(sharedPath, "References/", metadataAssembliesFile, sep = "")
```

Below the metadata file(s) specified by the user is/are read into R:
```{r copy_metadata_to_analysis_dir_and_read, cache=TRUE}
library(data.table)
metadata <-  fread(paste(sharedPathAn, metadataFileAlternate, sep = ""),
                   sep = ",", header = TRUE, quote = "")
metadata[, c("V1", "X"):=NULL]
setkey(metadata, ScientificName)
metadata <- metadata[!"Fusarium_sporotrichiodes"]

metadataAssemblies <- fread(paste(sharedPathAn, metadataAssemblyFile, sep = ""), sep = ",", header = TRUE, quote = "")
metadataAssemblies[, "V1":=NULL]
setkey(metadataAssemblies, ScientificName)
metadataAssemblies <- metadataAssemblies[!"Fusarium_sporotrichiodes"]
metadataAssemblies$AssemblyPath <- paste(sharedPathAn, "Assembly_Newbler/", metadataAssemblies$LibraryName, "/", 
                                       paste(metadataAssemblies$SppAbbr, "_assemblyLargeContigs_EG2018_mod.fna", sep = ""),
                                       sep = "")
```

The following chunk will integrate the user-defined variables from the previous chunk into the script.
```{r creating_dir_for_analysis, cache=TRUE}
# Create the analysis directory:
dir.create(paste(sharedPath, analysis, sep = ""), 
           showWarnings = TRUE, 
           recursive    = FALSE)

# Set the path to the analysis directory:
sharedPathAn <- paste(sharedPath, analysis, sep="")

# Create fastq directory in sharedPath folder based on "seqDataDir":
dir.create(paste(sharedPathAn, seqDataDir, sep = ""), 
           showWarnings = TRUE, 
           recursive    = FALSE)

# Set the path the fastq directory:
pathFastq <- paste(sharedPathAn, seqDataDir, "/", sep = "")
```

**Define path variables to programs and scripts used:**
```{r}
# Biocluster system-wide programs:
augustBioCPath  <- "/isilon/biodiversity/pipelines/maker-2.10/augustus.2.7/bin/augustus"
augEvalBioCPath <- "/isilon/biodiversity/pipelines/maker-2.10/augustus.2.7/bin/augustus"
bedtoolsPath    <- "/opt/bio/BEDTools/bin/bedtools"
blastallPath    <- "/opt/bio/ncbi/bin/blastall"
blastxDBnrPath  <- "/isilon/ottawa-rdc/reference/ncbi/blastdb/reference/nr/nr"
etrainBioCPath  <- "/isilon/biodiversity/pipelines/maker-2.10/augustus.2.7/bin/etraining"
optimAugustPath <- "/isilon/biodiversity/pipelines/maker-2.10/augustus.2.7/scripts/optimize_augustus.pl"
pathtRNA_scan   <- "/opt/bio/tRNAscan-SE/bin/tRNAscan-SE"
bowtie2BuildPath <- "/opt/bio/bowtie2/bowtie2-build"
samtools1Path    <- "/opt/bio/samtools1/bin/samtools1"

# *** Revisit this organization. Perhaps best that all programs be /home/ and databases be in local cfia-ottawa?
# CFIA-ACIA users home directory programs:
progPath        <- "/home/CFIA-ACIA/girouxeml/prog/"
aedCDFgenePath  <- paste(progPath, "scripts_pl/AED_cdf_generator.pl", sep = "")
blastpPath      <- paste(progPath, "miniconda/bin/blastp", sep = "")
buscoPath       <- paste(progPath, "busco/scripts/run_BUSCO.py", sep = "")
fathomPath      <- paste(progPath, "snap/fathom", sep = "")
forgePath       <- paste(progPath, "snap/forge", sep = "")
gagPath         <- paste(progPath, "gag/genomeannotation-GAG-40ea515/gag.py", sep = "")
genemarkPath    <- paste(progPath, "genemark-es/gmes_petap.pl", sep = "") 
hmmAssemPath    <- paste(progPath, "snap/hmm-assembler.pl", sep = "") 
iprUpdateMaker  <- paste(progPath, "maker/bin/ipr_update_gff", sep = "")
iprscan2gff3    <- paste(progPath, "maker/bin/iprscan2gff3", sep = "")
makerDatMapPath <- paste(progPath, "maker/bin/map_data_ids", sep = "")
makerMapFasta   <- paste(progPath, "maker/bin/map_fasta_ids", sep = "")
makerFastamerge <- paste(progPath, "maker/bin/fasta_merge", sep = "") 
makerFuncFasta  <- paste(progPath, "maker/bin/maker_functional_fasta", sep = "") 
makerFuncGff    <- paste(progPath, "maker/bin/maker_functional_gff", sep = "")
makerGFF3merge  <- paste(progPath, "maker/bin/gff3_merge", sep = "") 
makerIPR2gff3   <- paste(progPath, "maker/bin/iprscan2gff3", sep = "")
makerIPRupdate  <- paste(progPath, "maker/bin/ipr_update_gff", sep = "")
makerMapGffPath <- paste(progPath, "maker/bin/map_gff_ids", sep = "")
makerMapPath    <- paste(progPath, "maker/bin/maker_map_ids", sep = "")
makerPath       <- paste(progPath, "maker/bin/maker", sep = "") 
maker2zffPath   <- paste(progPath, "maker/bin/maker2zff", sep = "") 
pathtRNA_scan   <- paste(progPath, "tRNAscan-SE/bin/tRNAscan-SE", sep = "") 
processRepeatsPath <- paste(progPath, "RepeatMasker/ProcessRepeats", sep = "") 
repMaskerPath   <- paste(progPath, "RepeatMasker/RepeatMasker", sep = "") 
repModBuildDBPath  <- paste(progPath, "RepeatModeler-open-1.0.11/BuildDatabase", sep = "") 
repModlerPath   <- paste(progPath, "RepeatModeler-open-1.0.11/RepeatModeler", sep = "") 
rmOutToGFF3Path <- paste(progPath, "RepeatMasker/util/rmOutToGFF3.pl", sep = "")
tbl2asnPath     <- paste(progPath, "linux64.tbl2asn", sep = "")
zff2augGbkPath   <- paste(scriptsPath, "zff2augustus_gbk.pl", sep = "")

# CFIA-Ottawa-Fallowfield user directory programs:
programsPath    <- "/isilon/cfia-ottawa-fallowfield/users/girouxeml/prog/"
buscoFunDataSet <- paste(programsPath, "busco_datasets/fungi_odb9", sep = "")
buscoEukDataSet <- paste(programsPath, "busco_datasets/eukaryota_odb9", sep = "")
buscoStrpDataSet <- paste(programsPath, "busco_datasets/alveolata_stramenophiles_ensembl", sep = "")
```


Path to the P. ramorum reference fasta files:
```{r}
phraRefDir <- paste(referencesPath, "/Phytophthora_ramorum_reference/", sep = "")
phraRefGtf <- paste(phraRefDir, "JGI_B_Tyler_2004_Annotationv1-1_FM_Phyra1_1.gtf", sep = "")
phraRefFna <- paste(phraRefDir, "JGI_B_Tyler_2004_Annotationv1-1_unmasked_assembled_scaffolds_ramorum1.fasta", sep = "")
phraRefAA  <- paste(phraRefDir, "JGI_B_Tyler_2004_Annotationv1-1_proteins.FM_Phyra1_1.fasta", sep = "")
phraRefCds <- paste(phraRefDir, "JGI_B_Tyler_2004_Annotationv1-1_transcript.FM_Phyra1_1.fasta", sep ="")
```

### 1. De novo Repeat Identification.  
The first, and very important, step to genome annotation is identifying repetitive content. Existing libraries 
from Repbase or from internal efforts are great, but it is also important to identify repeats de novo from your reference 
genome using RepeatModeler. This is pretty easy to do and normally only takes a couple days using 8-12 cores.  
Why do this? 
If we were working with a well-studied organism, we wouldn't need to, we could just stick to the database that repeatmasker 
used which we updated with RepBase.
#### 1-A. Setting up directories.
**Make a directory within each species-specific directory that will contain all Repeat and MAKER annotation data:**
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(sharedPathAn, metadataAssemblies$LibraryName[k],
                     sep = ""), showWarnings = TRUE, recursive = FALSE)}

for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(sharedPathAn, metadataAssemblies$LibraryName[k], "/", 
                     paste(metadataAssemblies$SppAbbr[k], "RepeatDB", sep = "_"),
                     sep = ""), showWarnings = TRUE, recursive = FALSE)}

metadataAssemblies$RepeatDBPath <- paste(sharedPathAn, metadataAssemblies$LibraryName, "/",
                                         metadataAssemblies$SppAbbr, "_RepeatDB/", sep = "")
```

#### 1-B. Build a repeat database for RepeatModeler for each species.
```{r}
prefix <- "buildDB"
cmd <- with(metadataAssemblies, 
            paste("cd ", RepeatDBPath, " && ", repModBuildDBPath, " -name ", SppAbbr, " ", AssemblyPath, sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**Run RepeatModeler using the databases just made for each species:**
```{r}
node   <- 6
prefix <- "repeatModeler"

cmd <- with(metadataAssemblies,
            paste("cd ", RepeatDBPath, " && ", repModlerPath, " -pa ", node, " -database ", 
                  SppAbbr, " 2>&1 | tee repeatmodeler.log ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```

Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Note:**
Remember to use the modified assemblies that have the extra details that Newbler added after the >contig 
name (3 tabs for contig name, length and some other detail) removed because this info created problems downstream.    
  
**Note:** if there is an unexpected system failure, RepeatModeler can recover from it and continue from where it
previously left off. See the README file in its program directory.  

The next step is to copy all the consensi.fa.classified libraries to a directory and combine them, then separate 
fasta entries with known and unknown repeats. 
  
**Setting things up:**
```{r}
speciesRepeatDBname <- "spp_Phra_repeatDB"
dir.create(paste(sharedPathAn, "RepeatDatabases", sep = ""), showWarnings = TRUE, recursive = FALSE)
projRepeatDB <- paste(sharedPathAn, "RepeatDatabases/", sep = "")

dir.create(paste(projRepeatDB, speciesRepeatDBname, sep = ""), showWarnings = TRUE, recursive = FALSE)
allSppRepeatDBpath <- paste(projRepeatDB, speciesRepeatDBname, "/", sep = "")

tmp <- list()
for(i in 1:nrow(metadataAssemblies)){
    tmp[i] <- list.files(path = metadataAssemblies$RepeatDBPath[i], pattern = "^RM_.*")
    metadataAssemblies$RepeatModelerDir[i] <- tmp[i]
    metadataAssemblies$RepeatModelerPath[i] <- paste(metadataAssemblies$RepeatDBPath[i], 
                                                     metadataAssemblies$RepeatModelerDir[i], "/", sep = "")}

```

**Copying the files:**
```{r}
prefix <- "copy_Spp_RepModeler"
cmd <- with(metadataAssemblies, 
            paste("cp ", paste(metadataAssemblies$RepeatModelerPath, "consensi.fa.classified", sep = ""),
                  " ", paste(allSppRepeatDBpath, metadataAssemblies$SppAbbr, "_consensi.fa.classified", sep = "")))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Combine them into one file:**   
Run the command output in the following chunk on the command line.   
i.e.,   
$ bash Ohytophthora_consensi.fa.classified
```{r}
metadataAssemblies$repModelerConsensi <- paste(metadataAssemblies$SppAbbr, "_consensi.fa.classified", sep = "")
list   <- metadataAssemblies$repModelerConsensi
output <- paste(list, collapse = " ")
# I'm automating the output file name, since all the species in this set (*Lachnellula spp*), are within the same
# genus, but if this is not the case for another set, specify the output file name manually.
species <- c(metadataAssemblies$ScientificName)
genus   <- gsub("_.*", "", species)
genus   <- unique(genus)
repModAllsppFileName <- paste(genus, "consensi.fa.classified", sep = "_")
cmd <- paste("cat ", output, " > ", genus, "_", "consensi.fa.classified", sep = "")
write(cmd, file = paste(allSppRepeatDBpath, repModAllsppFileName, sep = ""))
```

**Split unknown and known repeats to separate files:**     
We'll use perl scripts for this (in ~/prog/scripts_pl/): _selectFasta_byIDUnknown.pl_, _selectFasta_byID_Known.pl_    
  
**Note:** You need to open these perl scripts and edit them to fix the names you want for input and output,
and you need to run them in the directory where your input is.   
i.e.,   
$ perl Known.pl Phytophthora_consensi.fa.classified
$ perl Unknown.pl Phytophthora_consensi.fa.classified
```{r}
allSppRepeatDBpath <- paste(projRepeatDB, speciesRepeatDBname, "/", sep = "")
infile   <- repModAllsppFileName
# Write script to parse and get all repeats that are "Known"
identity <- 1
parseFastaByHeaderPattern(infile, identity)

# Repeat the above with identity <- 2, to get all the unknown fastas:
identity <- 2
parseFastaByHeaderPattern(infile, identity)
```


#### 1-C. Quality check of the repeat database built with RepeatModeler.
QC the output from the unknown_Lachnellula_consensi.fa.classified repeat library to check for repeats that 
are really genes (gene families) or RNA features:

**Blastx vs nr:**  
I did this one on the command line. Blastx vs nr for protein coding genes:   
$ qsub -pe smp 22 -cwd -S /bin/bash repeat_nrCheck1.sub
```{r}
prefix <- "repeat_nrCheck"
node   <- 22 
cmd <- with(metadataAssemblies, 
            paste("blastx -db ", blastxDBnrPath, 
                  " -query ", paste(allSppRepeatDBpath, "Unknown_", repModAllsppFileName, sep = ""),
                  " -evalue 10e-5 -num_alignments 5 -num_threads ", node, 
                  " > ", paste(allSppRepeatDBpath, "Unknown_", repModAllsppFileName, ".nrcheck.blast.out", sep = ""),
                  sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

Look at the output from the Blastx and Blastn runs, and remove repeats that are actually really genes (gene families) or RNA features.

To look at the output (*.nrcheck.blast.out), search for "Sequences producing significant alignments", and remove those from the
Unknown_.consensi.fa.classified file.   

**Blastn vs RNA database for ribosomal or other RNA genes:**  
Blastn vs RNA database for ribosomal or other RNA genes. Rfam.fasta comes with the Rfam download and it requires you to
download the Rfam database. Do this only when it hasn't already been done, or if it's been a really
long time and you need to update the database:   
```{r}
cmd <- paste("cd ~/prog/rfam && wget -r ftp://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/fasta_files/ ",
             " && mv -f ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/fasta_files/ . ",
             " && gunzip RFO* ",
             " && cat *.fa > rfam.fasta ",
             " && mv RF* ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/fasta_files/ ",
             " && makeblastdb -in rfam.fasta -dbtype nucl ", sep = "")
```

**Run Blastn against the rfam database in the Lachnellula_species/RepeatDatabases/spp_Lach_repeatDB dir:**
```{r}
prefix <- "repeat_rfamCheck"
cmd    <- paste("blastn -db /home/CFIA-ACIA/girouxeml/prog/rfam/rfam.fasta -query ",
                paste(allSppRepeatDBpath, "Unknown_", infile, sep = ""),
                " -evalue 10e-5 -num_alignments 5 -num_threads 7 > ",
                paste(allSppRepeatDBpath, "Unknown_", infile, ".rnacheck.blast.out", sep = ""),
                sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

To look at the output (*.rnacheck.blast.out), search for "Sequences producing significant alignments", and remove those from the
Unknown_.consensi.fa.classified file, the same way done for nr check.  


**Convert the EMBL repeat library from RepeatMasker to fasta format:**  
Place the repeat library in its own dir:
```{r}
dir.create(paste(projRepeatDB, "embl_RepeatMaskerDB", sep = ""), showWarnings = TRUE, recursive = FALSE)

prefix <- "embl_buildRepMaskeLib"
cmd    <- paste("perl /home/CFIA-ACIA/girouxeml/prog/RepeatMasker/util/buildRMLibFromEMBL.pl ",
                "/home/CFIA-ACIA/girouxeml/prog/RepeatMasker/Libraries/RepeatMaskerLib.embl ",
                paste(allSppRepeatDBpath, "Known_", infile, sep = ""),
                " ", paste(allSppRepeatDBpath, "Unknown_", infile, sep = ""),
                " > ", paste(projRepeatDB, "embl_RepeatMaskerDB/RepeatMaskerLib.fasta", sep = ""),
                sep = "")
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
Further steps can be taken to annotate the resulting library, but the most important reason for this 
library is for downstream gene prediction. This step came from an example where a Boa library was 
combined with several other snakes and annotated:  
  
https://gist.github.com/darencard/bb1001ac1532dd4225b030cf0cd61ce2  
  
#### 1-D. Full Repeat Annotation with RepeatMasker:   
  
**Full Repeat Annotation:**  
Depending on the species, the de novo library can be fed right into MAKER, however, based on the very thorough example provided 
by https://gist.github.com/darencard/bb1001ac1532dd4225b030cf0cd61ce2, we'll be doing a more complex repeat identification.
  
**EMBL repeat library masking:**    
First, we mask using a currated library to overcome a previously-identified issue with the Repbase annotation. 
I used the known library from repeatmasker.lib.EMBL, which I converted to fasta format using RepeatMasker/util/buildRMLibFromEMBL.pl script.
Then we pass the species genome assemblies through the RepeatMaskerLib.fasta using RepeatMasker.
```{r}
for(i in 1:length(metadataAssemblies$RepeatDBPath)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[i], "embl_mask", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$embl_mask_path <- paste(metadataAssemblies$RepeatDBPath, "embl_mask/", sep = "")

prefix <- "embl_mask"
node   <- 12
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ", 
                     "cd ", embl_mask_path, " && RepeatMasker ", " -pa ", node, " -lib ",
                     paste(projRepeatDB, "embl_RepeatMaskerDB/RepeatMaskerLib.fasta ", sep = ""),
                     " -dir . ", AssemblyPath,
                     " && conda deactivate", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Known repeat library masking:**    
Then the masked FASTA from this search can be used as input for the next search. I also normally 
rename the outputs after each round so they are more representative of what they contain. Do 2 rounds, 
using the known and unknown *Phytophthora* repeat libraries created, split, so that the known elements 
would be preferentially annotated over unknown, to the degree possible.  
```{r}
for(i in 1:length(metadataAssemblies$RepeatDBPath)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[i], "Known_Mask", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$Known_Mask_path <- paste(metadataAssemblies$RepeatDBPath, "Known_Mask/", sep = "")

prefix <- "known_Mask"
node   <- 12
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", Known_Mask_path, " && RepeatMasker ", " -pa ", node, " -lib ",
                     paste(allSppRepeatDBpath, "Known_", infile, sep = ""),
                     " -dir . ", paste(embl_mask_path, "*.fna.masked", sep = ""),
                     " && conda deactivate", 
                     sep = ""))
# Run RepeatMasker with known repeat lib 1st, using as input the embl masked output
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Unknown repeat library masking:**    
Run RepeatMasker with unknown repeat lib, using as input the unknown masked output. Note, make sure to use the unknown lib
that was passed through NR, RNA, and BLAST checks to remove repeats that were actually part of genes or functional RNAs.
```{r}
for(i in 1:length(metadataAssemblies$RepeatDBPath)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[i], "Unknown_Mask", sep = ""), showWarnings = TRUE, recursive = FALSE)
}
metadataAssemblies$Unknown_Mask_path <- paste(metadataAssemblies$RepeatDBPath, "Unknown_Mask/", sep = "")

# Run RepeatMasker with unknown repeat lib 2nd, using as input the known masked output
prefix <- "unknown_Mask"
node   <- 12
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", Unknown_Mask_path, " && RepeatMasker ", " -pa ", node, " -lib ",
                     paste(allSppRepeatDBpath, "Unknown_", infile, sep = ""),
                     " -dir . ", paste(Known_Mask_path, "*.fna.masked.masked", sep = ""),
                     " && conda deactivate",
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
# Ignore the segmentation fault errors, these are tries over already masked strings
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Finally, results from each round must be analyzed together to produce the final repeat annotation:**
```{r}
# Make a directory in each species dir for the repeats masked with the embl lib:
for(i in 1:length(metadataAssemblies$RepeatDBPath)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[i], "Full_mask", sep = ""), showWarnings = TRUE, recursive = FALSE)}

prefix <- "copy_masked_rep_fna"
cmd    <- with(metadataAssemblies,
               paste("cp ", paste(RepeatDBPath, "Unknown_Mask/*.fna.masked.masked.masked ", sep = ""),
                     paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.fa", sep = ""),
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

prefix2 <- "copy_masked_rep_out"
cmd2    <- with(metadataAssemblies,
                paste("cp ", paste(RepeatDBPath, "Unknown_Mask/*.fna.masked.masked.out ", sep = ""),
                      paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.out", sep = ""),
                      sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix);RemoveQsubTempFiles(sharedPathAn, prefix2)
```

**Gunzip and then cat repeat outputs:**
```{r}
prefix <- "gunzipToCatRepeatFasta"
cmd    <- with(metadataAssemblies, 
               paste("gunzip ", 
                     paste(RepeatDBPath, "embl_mask/*.cat.gz ", sep = ""),
                     paste(RepeatDBPath, "Known_Mask/*.cat.gz ", sep = ""),
                     paste(RepeatDBPath, "Unknown_Mask/*.cat.gz ", sep = ""),
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Make a directory in each species dir for the final repeats masked:**
```{r}
for(i in 1:length(metadataAssemblies$RepeatDBPath)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[i], "Final_mask", sep = ""), showWarnings = TRUE, recursive = FALSE)
}

prefix <- "catRepeatFasta"
cmd    <- with(metadataAssemblies, 
               paste("cat ", 
                     paste(RepeatDBPath, "embl_mask/*.cat ", sep = ""),
                     paste(RepeatDBPath, "Known_Mask/*.cat ", sep = ""),
                     paste(RepeatDBPath, "Unknown_Mask/*.cat ", sep = ""),
                     " > ", paste(RepeatDBPath, "Final_mask/", SppAbbr, ".assembly.full_mask.cat", sep = ""),
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Process the repeats:**
```{r}
prefix <- "processRepeats"
cmd    <- with(metadataAssemblies, 
               paste("conda activate makerenv && ProcessRepeats  -species fungi ", 
                     paste(RepeatDBPath, "Final_mask/*.full_mask.cat ", sep = ""),
                     " && conda deactivate",
                     sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
Finally, in order to feed these repeats into MAKER properly, we must separate out the complex repeats (more info on this below).  
**Create GFF3:**
```{r}
prefix <- "rmOutToGFF3"
cmd    <- with(metadataAssemblies, 
               paste("conda activate makerenv && ", rmOutToGFF3Path, " ", 
                     paste(RepeatDBPath, "Full_mask/*.full_mask.out ", sep = ""),
                     " > ", paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.out.gff3", sep = ""),
                     " && conda deactivate", sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Isolate complex repeats:**
```{r}
prefix <- "isolate_complex_Repeats"
cmd    <- with(metadataAssemblies, 
               paste('grep -v -e "Satellite" -e ")n" -e "-rich"',
                     " ", paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.out.gff3", sep = ""),
                     " > ", paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.complex.gff3", sep = ""),
                     sep = ""))
            
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Clean-up step:
Remove the output files while keeping the qsub and bash file:
```{r, cache=TRUE}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
**Reformat to work with MAKER:**   
**Note:**  
I can't seem to be able to generate the commands I want for this one. The commands are in the chunk below, and 
I passed them on the terminal in each directory manually.
```{r}
cmd <- with(metadataAssemblies,
            paste("cat ", paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.complex.gff3 ", sep = ""),
                  " | ",
                  cat(paste("perl -ane '$id; if(!/^\\#/){@F = split(/\\t/, $_); chomp $F[-1];$id++; $F[-1] .= \"\\;ID=$id\"; $_ = join(\"\\t\", @F).\"\\n\"} print $_' ")),
                  " > ",
                  paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.complex.reformat.gff3 ", sep = ""),
                  sep =""))

cmd <- with(metadataAssemblies,
            paste("cat ", paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.complex.gff3 ", sep = ""),
                  " | \\ ", paste("perl -ane '$id; if(!/^\\#/){@F = split(/\\t/, $_); chomp $F[-1];$id++; $F[-1] .= \"\\;ID=$id\"; $_ = join(\"\\t\", @F).\"\\n\"} print $_' "),
                  "\\ > ",
                  paste(RepeatDBPath, "Full_mask/", SppAbbr, ".assembly.full_mask.complex.reformat.gff3 ", sep = ""),
                  sep =""), sep = "")


# cat /isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/pramorum_strain_differentiation/Phra1_7964/Phra1_RepeatDB/Full_mask/Phra1.assembly.full_mask.complex.gff3  | \
#  perl -ane '$id; if(!/^\#/){@F = split(/\t/, $_); chomp $F[-1];$id++; $F[-1] .= "\;ID=$id"; $_ = join("\t", @F)."\n"} print $_' \
#  > /isilon/cfia-ottawa-fallowfield/users/girouxeml/PIRL_working_directory/pramorum_strain_differentiation/Phra1_7964/Phra1_RepeatDB/Full_mask/Phra1.assembly.full_mask.complex.reformat.gff3

# cat Phra2.assembly.full_mask.complex.gff3 | \
# perl -ane '$id; if(!/^\#/){@F = split(/\t/, $_); chomp $F[-1];$id++; $F[-1] .= "\;ID=$id"; $_ = join("\t", @F)."\n"} print $_' \
# > Phra2.assembly.full_mask.complex.reformat.gff3

```

Now we have the prerequisite data for running MAKER. Add this to the data table:
```{r}
metadataAssemblies$makerFullMaskGFF3 <- paste(metadataAssemblies$RepeatDBPath, "Full_mask/",
                                              metadataAssemblies$SppAbbr, ".assembly.full_mask.complex.reformat.gff3", sep = "")
```
### 2. Annotation using Genemark-ES.  
Before we run MAKER, we can run Genemark-es, which requires no other input but the genome assemblies. This is supposed to be especially 
useful for fungal genomes. Once this is running, you can continue on with the chunk that gets the initial run of MAKER going, since it doesn't
depend on the genemark-es outputs for the first round of MAKER.  
It's a bit tricky to install the genemark-es due to dependencies, but works by installing one at a time all
dependencies using **cpanm**. Also, there was an error when trying to run it at first:  
  
/usr/bin/perl: symbol lookup error: /home/CFIA-ACIA/girouxeml/perl5/lib/perl5/x86_64-linux-thread-multi/auto/List/Util/Util.so: undefined symbol: Perl_xs_apiversion_bootcheck  
  
The fix was to remove the directory in _**~/perl5/lib/perl5/x86_64-linux-thread-multi/auto/List/Util/**_ and just 
placing it in my home directory (or if you want you can just delete it too):  
  
**_$ cd ~/perl5/lib/perl5/_**  
**_$ mv -f x86_64-linux-thread-multi_** **~**  
  
See: https://www.reddit.com/r/openbsd/comments/65efvo/openbsd_61_perl_problem_undefined_symbol_perl_xs/  
#### 2-A. Setting up paths to run Genemark-es in the species RepeatDB directory:
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[k], "genemark-es_round1", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$genemarkEsRnd1Path <- paste(metadataAssemblies$RepeatDBPath, "genemark-es_round1/", sep = "")
```

#### 2-B. Run The first round of Genemark-es in the maker_round1 dir:   
*** Note - I had issues with genemark until I edited the gmes.cfg file for min contig length from 50000 to 1000.
```{r}
prefix <- "genemark-ES_rnd1"
node   <- 8
cmd    <- with(metadataAssemblies,
               paste("cd ", genemarkEsRnd1Path, " && ",
                     " perl ", genemarkPath, " --ES --fungus --cores ", node, " --v ",
                     " --sequence ", AssemblyPath, sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

#### 2-C. Rename the output file to include the organism name:
```{r}
cmd <- with(metadataAssemblies,
            paste("cd ", genemarkEsRnd1Path, " && ",
                  "mv output/gmhmm.mod output/", paste(SppAbbr, "_GMES.mod", sep = ""), sep = ""))
sapply(cmd, function(x) system(x))
```

### 3. MAKER Round 1: Initial MAKER Analysis.  
MAKER is pretty easy to get going and relies on properly completed control files. In this first round, we will be
providing the data files for the repeat annotation (rm_gff), the transcriptome assembly (est), and extra protein files from
related species, which we have retrieved and saved in our References directory. We will also set the model_org to 'simple' 
so that only simple repeats are annotated (along with RepeatRunner).
```{r}
for(i in 1:length(metadataAssemblies$RepeatDBPath)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[i], "maker_round_1", sep = ""), showWarnings = TRUE, recursive = FALSE)
}
metadataAssemblies$maker_rnd1_path <- paste(metadataAssemblies$RepeatDBPath, "maker_round_1/", sep = "")
```

#### 3-A. Generate the MAKER control files.
```{r}
prefix <- "maker_rnd1_CTL"
cmd    <- with(metadataAssemblies, 
               paste("conda activate makerenv && ",
                     "cd ", maker_rnd1_path, " && maker -CTL ",
                     "conda deactivate",
                     sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
metadataAssemblies$makerRnd1_CTL_optsPath <- paste(metadataAssemblies$maker_rnd1_path, "maker_opts.ctl", sep = "")
metadataAssemblies$makerRnd1_CTL_exePath  <- paste(metadataAssemblies$maker_rnd1_path, "maker_exe.ctl", sep = "")
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

#### 3-B. Edit the MAKER control files.  
**The commands below will edit the altest, altest_gff, model_org, augustus_species, est2genome, protein2genome, and min_contig:**
```{r}
cmd <- with(metadataAssemblies,
            paste("/opt/rocks/bin/replace",
                  " altest= ", paste("altest=", phraRefCds, sep = ""),
                  " altest_gff= ", paste("altest_gff=", phraRefGtf, sep = ""),
                  " model_org=all ", "model_org=simple ",
                  #" augustus_species= ", "augustus_species=fusarium_graminearum ",
                  " est2genome=0 ", "est2genome=1 ",
                  " protein2genome=0 ", "protein2genome=1 ",
                  " min_contig=1 ", "min_contig=1000 ",
                  " -- ", makerRnd1_CTL_optsPath,
                  sep = ""))

sapply(cmd, function(x) system(x))
```
**Edit the maker_opts.ctl genome paths, and protein paths and rm_gff (repeat modeler) paths to point to desired files:**
```{r}
# Edit Genome paths:
newPattern <- paste("genome=", metadataAssemblies$AssemblyPath, sep = "")
pattern    <- "genome= "

for(i in 1:nrow(metadataAssemblies)){
    makerOptsGenRepl(metadataAssemblies$makerRnd1_CTL_optsPath[i], pattern, newPattern[i])}

# Edit protein path pattern, using this function to make sure "protein= " is edited, and not
# "repeat_protein=/home/CFIA-ACIA/girouxeml/prog/maker/data/te_proteins.fasta".
pattern    <- "protein= "
newPattern <- paste("protein=", phraRefAA, sep = "")

for(i in 1:nrow(metadataAssemblies)){
    makerOptsGenRepl(metadataAssemblies$makerRnd1_CTL_optsPath[i], pattern, newPattern)}

# Edit repeat modeler, "rm_gff= ", path:
pattern    <- "rm_gff= "
newPattern <- paste("rm_gff=", metadataAssemblies$makerFullMaskGFF3, sep = "")

for(i in 1:nrow(metadataAssemblies)){
    makerOptsGenRepl(metadataAssemblies$makerRnd1_CTL_optsPath[i], pattern, newPattern[i])}
```
For the maker_exec files, need to set to the following:   

#-----Location of Executables Used by MAKER/EVALUATOR   
makeblastdb=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/makeblastdb #location of NCBI+ makeblastdb executable   
blastn=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/blastn #location of NCBI+ blastn executable  
blastx=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/blastx #location of NCBI+ blastx executable   
tblastx=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/tblastx #location of NCBI+ tblastx executable   
formatdb=/opt/bio/ncbi/bin/formatdb #location of NCBI formatdb executable   
blastall=/opt/bio/ncbi/bin/blastall #location of NCBI blastall executable   
xdformat= #location of WUBLAST xdformat executable   
blasta= #location of WUBLAST blasta executable   
RepeatMasker=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/share/RepeatMasker/RepeatMasker #location of RepeatMasker executable  
exonerate=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/exonerate #location of exonerate executable   
   
#-----Ab-initio Gene Prediction Algorithms   
snap=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/snap #location of snap executable  
gmhmme3=/home/CFIA-ACIA/girouxeml/prog/genemark-es/gmhmme3 #location of eukaryotic genemark executable   
gmhmmp= #location of prokaryotic genemark executable  
augustus=/home/CFIA-ACIA/girouxeml/prog/miniconda/pkgs/augustus-3.2.3-boost1.57_0/bin/augustus #location of augustus executable   
fgenesh= #location of fgenesh executable   
tRNAscan-SE=/home/CFIA-ACIA/girouxeml/prog/tRNAscan-SE/bin/tRNAscan-SE #location of trnascan executable  
snoscan=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/snoscan #location of snoscan executable  
   
#-----Other Algorithms  
probuild=/home/CFIA-ACIA/girouxeml/prog/genemark-es/probuild #location of probuild executable (required for genemark)  

Also, I'm using the repeatmasker installation in my ~/prog/RepeatMasker directory - not the install from conda. Install from
conda would require complete re-set up of RepBase for RepeatMasker.

#### 3-C. Run MAKER.  
Given MAKER will be using BLAST to align transcripts and proteins to the genome, this will take at 
least a couple days with 12 cores. Speed is a product of the resources you allow (more cores == faster) 
and the assembly quality (smaller, less contiguous scaffolds == longer).
```{r}
prefix <- "maker_round_1_run"
node   <- 12
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ", "cd ", maker_rnd1_path, " && maker ", #makerPath, 
                     " -base ", paste(SppAbbr, "_rnd1", sep = ""),
                     " ", paste(maker_rnd1_path, "maker_opts.ctl", sep = ""),
                     " ", paste(maker_rnd1_path, "maker_bopts.ctl", sep = ""),
                     " ", paste(maker_rnd1_path, "maker_exe.ctl", sep = ""),
                     " -cpus ", node,  
                     " && conda deactivate ", sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

#### 3-D. Assemble the MAKER GFF and FASTA outputs.
```{r}
metadataAssemblies$makerRnd1_OutputPath <- paste(metadataAssemblies$maker_rnd1_path, 
                                                 metadataAssemblies$SppAbbr, "_rnd1.maker.output/", sep = "")

# GFF with the sequences:
prefix <- "mergeGFF3_maker"
cmd    <- with(metadataAssemblies,
               paste("cd ", makerRnd1_OutputPath, " && conda activate makerenv && gff3_merge -s -d ",
                     paste(makerRnd1_OutputPath, SppAbbr, "_rnd1_master_datastore_index.log", sep = ""),
                     " > ", paste(makerRnd1_OutputPath, SppAbbr, "_rnd1.all.maker.gff3", sep = ""),
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

# Collect all the fastas:
prefix2 <- "fastaMerge_maker"
cmd2    <- with(metadataAssemblies,
                paste("cd ", makerRnd1_OutputPath, " && conda activate makerenv && fasta_merge -d ",
                      paste(makerRnd1_OutputPath, SppAbbr, "_rnd1_master_datastore_index.log", sep = ""),
                      " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)

# GFF without the sequences:
prefix3 <- "mergeGFF3_maker_noseq" 
cmd3    <- with(metadataAssemblies,
                paste("cd ", makerRnd1_OutputPath, " && conda activate makerenv && gff3_merge -n -s -d ",
                      paste(makerRnd1_OutputPath, SppAbbr, "_rnd1_master_datastore_index.log", sep = ""),
                      " > ", paste(makerRnd1_OutputPath, SppAbbr, "_rnd1.all.maker.noseq.gff3", sep = ""),
                     " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd3, prefix3, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix); RemoveQsubTempFiles(sharedPathAn, prefix2); RemoveQsubTempFiles(sharedPathAn, prefix3)
```

### 4. Training Gene Prediction Software SNAP and Augustus.  
Besides mapping the empirical transcript and protein evidence to the reference genome and repeat annotation 
(not much of this in our example, given we've done so much up front), the most important product of this MAKER 
run is the gene models. These are used for training gene prediction software like augustus and snap.  
  
#### 4-A. Training SNAP.  
SNAP is pretty quick and easy to train. Issuing the following commands will perform the training. It's best 
to put some thought into what kind of gene models you use from MAKER. Ideally we would like to have sufficient 
evidence to filter to use models with an AED of 0.25 or better and a length of 50 or more amino acids 
(maker2zff -x 0.25 -l 50), which helps get rid of junky models, but we do not have enough evidence to support this 
for our data (no EST or transcript data for our specific organism), and it will result in nothing being returned. 
But we can specify all filter parameters so that at least we can filter based on AED and length, and set all other options
dependant on EST evidence to 0, which is still better than setting it to no filters (-n).  
  
We start with exporting 'confident' gene models from round 1 of MAKER for use in retraining SNAP. We'll generate some summary stats
of the models, and then collecting the training sequences and generating training parameters for BUSCO to train Augustus.  
  
**Export confident gene models from round 1 of MAKER using maker2zff:**  
For determining which genes are High Confidence for Retraining:
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$maker_rnd1_path[k], "snap", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$snapMakerRnd1Path <- paste(metadataAssemblies$maker_rnd1_path, "snap/", sep = "")

for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$snapMakerRnd1Path[k], "round1", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$snapRnd1MakerRnd1Path <- paste(metadataAssemblies$snapMakerRnd1Path, "round1/", sep = "")

prefix <- "snapMaker2zff"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd1Path, " && conda activate makerenv && maker2zff -x 0.25 -l 50 -c 0 -e 0 -o 0 -d ", 
                     paste(makerRnd1_OutputPath, SppAbbr, "_rnd1_master_datastore_index.log", sep = ""), 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Take a quick look at number of seqs in genome.dna file:**
```{r}
cmd <- with(metadataAssemblies, paste("cd ", snapRnd1MakerRnd1Path, " && ", 'grep ">" genome.dna | wc -l ', sep = ""))
sapply(cmd, function(x) system(x))

# 20 contigs...?
cmd <- with(metadataAssemblies, file.rename(paste(snapRnd1MakerRnd1Path, "genome.dna", sep = ""),
                                            paste(snapRnd1MakerRnd1Path, SppAbbr, "_rnd1.zff.dna", sep = "")))
sapply(cmd, function(x) system(x))

cmd <- with(metadataAssemblies, file.rename(paste(snapRnd1MakerRnd1Path, "genome.ann", sep = ""),
                                            paste(snapRnd1MakerRnd1Path, SppAbbr, "_rnd1.zff.ann", sep = "")))
sapply(cmd, function(x) system(x))
```

**Gather some stats and validate using fathom:**
```{r}
prefix <- "fathom_MakerRnd1_stats"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd1Path, " && conda activate makerenv && fathom ",
                     paste(SppAbbr, "_rnd1.zff.ann", sep = ""),
                     " ", paste(SppAbbr, "_rnd1.zff.dna", sep = ""),
                     " -gene-stats > gene-stats.log 2>&1 ", 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

prefix2 <- "fathom_MakerRnd1_validate"
cmd2    <- with(metadataAssemblies, 
                paste("cd ", snapRnd1MakerRnd1Path, " && conda activate makerenv && fathom ",
                      paste(SppAbbr, "_rnd1.zff.ann", sep = ""),
                      " ", paste(SppAbbr, "_rnd1.zff.dna", sep = ""),
                      " -validate > validate.log 2>&1 ", 
                      " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix); RemoveQsubTempFiles(sharedPathAn, prefix2)
```
**Collect the training sequences and annotations, plus 1000 surrounding bp for training using fathom:**
```{r}
prefix <- "fathom_MakerRnd1_categorize"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd1Path, " && conda activate makerenv && fathom ",
                     paste(SppAbbr, "_rnd1.zff.ann", sep = ""),
                     " ", paste(SppAbbr, "_rnd1.zff.dna", sep = ""),
                     " -categorize 1000 > categorize.log 2>&1 ", 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
Wait for the chunk above to complete before running this next one. It depends on the output from the 
previous as input.
```{r}
prefix2 <- "fathom_MakerRnd1_export"
cmd2    <- with(metadataAssemblies,
                paste("cd ", snapRnd1MakerRnd1Path, " && conda activate makerenv && fathom ",
                      " uni.ann uni.dna -export 1000 -plus > uni-plus.log 2>&1 ", 
                      " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix); RemoveQsubTempFiles(sharedPathAn, prefix2)
```

**Create the training parameters:**
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$snapMakerRnd1Path[k], "round1/params", sep = ""),
               showWarnings = TRUE, recursive = FALSE)}

prefix <- "forge_MakerRnd1"
cmd    <- with(metadataAssemblies,
               paste("cd ", paste(snapRnd1MakerRnd1Path, "params/", sep = ""), " && conda activate makerenv && forge ",
                     " ../export.ann ../export.dna > ../forge.log 2>&1 ", 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Assemble the HMM:**
```{r}
prefix <- "hmmAssembler_MakerRnd1"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd1Path, " && conda activate makerenv && hmm-assembler.pl ",
                     paste(SppAbbr, "_rnd1.zff", sep = ""),
                     " params > ", paste(SppAbbr, "_rnd1.zff.hmm", sep = ""), 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
#### 4-B. Training Augustus using BUSCO.  
**Augustus**  
Training Augustus is a more laborious process. Luckily, the recent release of BUSCO provides a nice pipeline 
for performing the training, while giving you an idea of how good your annotation already is (If you don't want 
to go this route, there are scripts provided with Augustus to perform the training). First, the Parallel::ForkManager 
module for Perl is required to run BUSCO with more than one core. You can easily install it before the first time 
you use BUSCO by running:   
  
_**$ sudo apt-get install libparallel-forkmanager-perl**_  
_**$ cpanm Parallel::ForkManager**_  
  
**Excise regions with mRNA annotations from MAKER round 1**    
This probably isn't an ideal training environment, but appears to work well. First, we must put together training 
sequences using the gene models we created in our first run of MAKER. We do this by issuing the following command 
to excise the regions that contain mRNA annotations based on our initial MAKER run (with 1000bp on each side).
```{r}
prefix <- "maker-augustus_get_mRNA_regions_Rnd1"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd1Path, " && ",
                     paste(' awk -v OFS="\t" \'{ if ($3 == "mRNA") print $1, $4, $5 }\'', sep = ""),
                     " ", paste(makerRnd1_OutputPath, SppAbbr, "_rnd1.all.maker.noseq.gff3", sep = ""),
                     " | \ ",
                     paste('awk -v OFS="\t" \'{ if ($2 < 1000) print $1, "0", $3+1000; else print $1, $2-1000, $3+1000 }\'', sep = ""),
                     " | \ ",
                     bedtoolsPath, " getfasta -fi ", AssemblyPath, " -bed - -fo ",
                     paste(SppAbbr, "_rnd1.all.maker.transcripts1000.fasta", sep = "")))

# Note, open the bash scripts, and edit so put the "\t" back in.
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

There are some important things to note based on this approach. First is that you will likely get warnings from 
BEDtools that certain coordinates could not be used to extract FASTA sequences. This is because the end coordinate 
of a transcript plus 1000 bp is beyond the total length of a given scaffold. This script does account for transcripts 
being within the beginning 1000bp of the scaffold, but there was no easy way to do the same with transcripts within 
the last 1000bp of the scaffold. This is okay, however, as we still end up with sequences from thousands of gene models 
and BUSCO will only be searching for a small subset of genes itself.  
  
While we've only provided sequences from regions likely to contain genes, we've totally eliminated any existing annotation 
data about the starts/stops of gene elements. Augustus would normally use this as part of the training process. However, 
BUSCO will essentially do a reannotation of these regions using BLAST and built-in HMMs for a set of conserved genes 
(hundreds to thousands). This has the effect of recreating some version of our gene models for these conserved genes. We 
then leverage the internal training that BUSCO can perform (the --long argument) to optimize the HMM search model to train 
Augustus and produce a trained HMM for MAKER. Here is the command we use to perform the Augustus training inside BUSCO.  
  
In this case, we are using the alveolata_stramenophiles_ensembl set of conserved genes (N=234 genes) because we are dealing with oomycetes, which fall under stramenopiles. BUSCO will try to identify those genes using BLAST and an initial HMM model for each that comes stocked within the BUSCO database. 
We specify the -m genome option since we are giving BUSCO regions that include more than just transcripts. The initial HMM model we'll use is the generic augustus set, since there are no closely-related species in the default augustus species list. Finally, the --long 
option tells BUSCO to use the initial gene models it creates to optimize the HMM settings of the raw HMM, thus training 
it for our use on Phytophthora ramorum. We can have this run in parallel on several cores, but it will still likely take days, 
so be patient.  Note, some of the options are kept in the config.ini file in the busco/config/ directory. Also, if during the run 
it keeps crashing with segmentation fault, core dumped, it may be an error with the threading. Try running on just one core. It may 
take a lot longer though, but at least it's still moving along.  
**Run BUSCO:**
```{r}
prefix <- "Busco_MakerRnd1"
node   <- 15
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ", 
                     "cd ", snapRnd1MakerRnd1Path, " && ",
                     "python ", buscoPath, " -i ", paste(SppAbbr, "_rnd1.all.maker.transcripts1000.fasta", sep = ""),
                     " -o ", paste(SppAbbr, "_rnd1_maker", sep = ""), " -c ", node,
                     " -l ", buscoStrpDataSet, " -m genome -sp generic -z --augustus_parameters='--progress=true'",
                     # " --long --restart",
                     " --long ",
                     " -f ", # If forced to restart and there is a problem with the previous run and you shouldn't use restart.
                     " && conda deactivate", sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
# Note, if the run fails, restart the run with the following "--restart", it will continue from where it left off. However, check the 
# config.ini file in ~/prog/busco/config/ to make sure that restart is set to True, and that you adjust to the correct cpus number.
```
**To remove the output files after you are done:**
```{r}
# system("/opt/gridengine/bin/linux-x64/qstat") # Remove qsub temp when qstat returns nothing.
RemoveQsubTempFiles(sharedPathAn, prefix)
cmd <- with(metadataAssemblies, paste("cd ", snapRnd1MakerRnd1Path, " && rm -rf tmp ", sep = ""))
sapply(cmd, function(x) system(x))
cmd <- with(metadataAssemblies, paste("cd ", snapRnd1MakerRnd1Path, " && rm core.* ", sep = ""))
sapply(cmd, function(x) system(x))
```
Phra1:   
BUSCO was run in mode: genome   
C:62.8%[S:47.0%,D:15.8%],F:1.7%,M:35.5%,n:234   
147 Complete BUSCOs (C)   
110 Complete and single-copy BUSCOs (S)   
37 Complete and duplicated BUSCOs (D)   
4 Fragmented BUSCOs (F)   
83 Missing BUSCOs (M)   
234 Total BUSCO groups searched   
   
Phra2:   
BUSCO was run in mode: genome   
C:74.3%[S:56.4%,D:17.9%],F:1.3%,M:24.4%,n:234
174 Complete BUSCOs (C)
132 Complete and single-copy BUSCOs (S)
42 Complete and duplicated BUSCOs (D)
3 Fragmented BUSCOs (F)
57 Missing BUSCOs (M)
234 Total BUSCO groups searched

Once BUSCO is complete, it will give you an idea of how complete your annotation is (though be cautious, 
because we haven't filtered away known alternative transcripts that will be binned as duplicates). We need 
to do some post-processing of the HMM models to get them ready for MAKER. First, we'll rename the files within
/maker_round_1/snap/round1/run_Lsue_rnd1_maker/augustus_output/retraining_parameters. 
  
**Rename output files from the BUSCO run:**
```{r}
metadataAssemblies$BuscoOut <- paste(metadataAssemblies$snapRnd1MakerRnd1Path, 
                                     "run_", metadataAssemblies$SppAbbr, "_rnd1_maker/", sep = "")
metadataAssemblies$BuscoRetrainParam <- paste(metadataAssemblies$BuscoOut, "augustus_output/retraining_parameters/", sep = "")

fl <- list.files(metadataAssemblies$BuscoRetrainParam, full.names = TRUE)

# Rather than develop a script, I went to each dir and used rename on the files:
# ~/perl5/bin/rename 's/BUSCO_Phra1_rnd1_maker_2983749754/Phytophthora_ramorum1/g' *
```
**Rename the files cited within the output files from the BUSCO run:**  
We also need to rename the files cited within certain HMM configuration files:
```{r}
# sed -i 's/BUSCO_Phra2_rnd1_maker_2154325496/Phytophthora_ramorum2/g' Phytophthora_ramorum2_parameters.cfg
```
**Add the newly-trained Augustus retraining parameter files to the Augustus species library directory:**  
Finally, we must copy these into the $AUGUSTUS_CONFIG_PATH species HMM location so they are accessible 
by Augustus and MAKER. I had put the $AUGUSTUS_CONFIG_PATH in the .bash_profile, after copying the 
directory from the isilon MAKER pipeline, for MAKER version 2.10. This is because I do not have 
write access to the isilon directory, but I do have it for my local directory.  
  
Do this from within the dir /maker_round_1/snap/round1/run_Phra1_rnd1_maker/augustus_output/retraining_parameters/
I did this on the command line, using scientific name and 1 or 2 to distinguish the Phra1 and Phra2 sets.
```{r}
# for(k in 1:nrow(metadataAssemblies)){
#     dir.create(paste("/isilon/cfia-ottawa-fallowfield/users/girouxeml/prog/augustus/config/species/", 
#                      metadataAssemblies$ScientificName[k], sep = ""),
#                showWarnings = TRUE, recursive = FALSE)
# }
# 
# cmd <- with(metadataAssemblies,
#             paste("cd ", BuscoRetrainParam, " && cp ", ScientificName, "*", 
#                   " /isilon/cfia-ottawa-fallowfield/users/girouxeml/prog/augustus/config/species/", ScientificName, sep = ""))
# sapply(cmd, function(x) system(x))
```

### 5. MAKER round 2 with ab initio Gene Predictors.  
Now let's run a second round of MAKER, but this time we will have Genemark-es, SNAP and Augustus run 
within MAKER to help create more sound gene models. MAKER will use the annotations from these two 
prediction programs when constructing its models. Before running, let's first recycle the mapping of 
empicial evidence we have from the first MAKER round, so we don't have to perform all the BLASTs, etc. again.

#### 5-A. Recycle the mapping and empirical evidence obtained from the first round with MAKER:
```{r}
# Transcript alignments - our file will be empty, as we have no est or transcript evidence, so may need to fix this:
prefix <- "maker_rnd2_transcript_evidence"
cmd    <- with(metadataAssemblies,
               paste("cd ", makerRnd1_OutputPath, " && ",
                     paste(" awk '{ if ", '($2 == "est2genome") print $0 }', "'", sep = ""),
                     " ", paste(SppAbbr, "_rnd1.all.maker.noseq.gff3", sep = ""), 
                     " > ", paste(SppAbbr, "_rnd1.all.maker.est2genome.gff3", sep = ""),
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

# Protein alignments:
prefix2 <- "maker_rnd2_protein_evidence"
cmd     <- with(metadataAssemblies,
                paste("cd ", makerRnd1_OutputPath, " && ",
                      paste(" awk '{ if ", '($2 == "protein2genome") print $0 }', "'", sep = ""),
                      " ", paste(SppAbbr, "_rnd1.all.maker.noseq.gff3", sep = ""), 
                      " > ", paste(SppAbbr, "_rnd1.all.maker.protein2genome.gff3", sep = ""),
                      sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix2, suffix)

# Repeat alignments:
prefix3 <- "maker_rnd2_repeat_evidence"
cmd     <- with(metadataAssemblies,
                paste("cd ", makerRnd1_OutputPath, " && ",
                      paste(" awk '{ if ", '($2 ~ "repeat") print $0 }', "'", sep = ""),
                      " ", paste(SppAbbr, "_rnd1.all.maker.noseq.gff3", sep = ""), 
                      " > ", paste(SppAbbr, "_rnd1.all.maker.repeats.gff3", sep = ""),
                      sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix3, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix); RemoveQsubTempFiles(sharedPathAn, prefix2); RemoveQsubTempFiles(sharedPathAn, prefix3)
```

**Now go up to the RepeatDB dir, and create a dir for the next round of MAKER:**
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$RepeatDBPath[k], "maker_round_2", sep = ""), 
               showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$maker_rnd2_path <- paste(metadataAssemblies$RepeatDBPath, "maker_round_2/", sep = "")
```

#### 5-B. Generate the MAKER round 2 control files:  
```{r}
prefix <- "maker_rnd2_CTL"
cmd    <- with(metadataAssemblies, 
               paste("conda activate makerenv && ",
                     "cd ", maker_rnd2_path, " && maker -CTL ",
                     "conda deactivate",
                     sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
metadataAssemblies$makerRnd2_CTL_optsPath <- paste(metadataAssemblies$maker_rnd2_path, "maker_opts.ctl", sep = "")
metadataAssemblies$makerRnd2_CTL_exePath  <- paste(metadataAssemblies$maker_rnd2_path, "maker_exe.ctl", sep = "")
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```


#### 5-C. Edit the MAKER round 2 control files.  
  
Modify the control file, removing the FASTA sequences files to map and replacing them with the GFFs (est_gff, 
protein_gff, and rm_gff, respectively. We can also specify the path to the Genemark-es .mod, SNAP HMM and the 
species name for Augustus, so that these gene prediction programs are run. We will also switch est2genome and 
protein2genome to 0 so that gene predictions are based on the Augustus and SNAP gene models. Unfortunately we 
do not have est or transcript evidence to use, so instead I used the gff3 of the botrytis cinerea model, which 
may be a mistake. I set est2genome=0. I also installed the trnascan program locally, following the instructions 
on: https://iamphioxus.org/2016/01/20/installing-trnascan-se-and-snoscan/ and added the following to my .bash_profile:
$ export Path="/home/CFIA-ACIA/girouxeml/prog/tRNAscan-SE/bin:$PATH"
$ PERL5LIB=~prog/tRNAscan-SE/bin

Note: If working in a conda environment, such as makerenv that I've created, create a sym link that will
point to where I am storing the augustus/config/species directories. This is bacause conda writes everything to my home 
directory, which is limited for space, so I store the databases where I have more space:   
$ ln -s /isilon/cfia-ottawa-fallowfield/users/girouxeml/prog/augustus/config/species /home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/config/species
```{r}
cmd <- with(metadataAssemblies,
            paste("/opt/rocks/bin/replace ",
                  " altest= ", paste("altest=", phraRefCds, sep = ""),
                  " altest_gff= ", paste("altest_gff=", phraRefGtf, sep = ""),
                  " protein_gff= ", paste("protein_gff=", makerRnd1_OutputPath, SppAbbr, "_rnd1.all.maker.protein2genome.gff3", sep = ""),
                  " model_org=all model_org=# ",
                  " repeat_protein= repeat_protein=# ",
                  " rm_gff= ", paste("rm_gff=", makerRnd1_OutputPath, SppAbbr, "_rnd1.all.maker.repeats.gff3", sep = ""),
                  " snaphmm= ", paste("snaphmm=", snapRnd1MakerRnd1Path, SppAbbr, "_rnd1.zff.hmm", sep = ""),
                  " gmhmm= ", paste("gmhmm=", genemarkEsRnd1Path, "output/", SppAbbr, "_GMES.mod", sep = ""),
                  " augustus_species= ", paste("augustus_species=", ScientificName, " ", sep = ""),
                  " trna=0 trna=1 ",
                  " max_dna_len=100000 max_dna_len=300000 ",
                  " -- ", makerRnd2_CTL_optsPath,
                  sep = ""))
sapply(cmd, function(x) system(x))

# Edit Genome paths:
pattern    <- "genome= "
newPattern <- paste("genome=", metadataAssemblies$AssemblyPath, sep = "")
for(i in 1:nrow(metadataAssemblies)){
    makerOptsGenRepl(metadataAssemblies$makerRnd2_CTL_optsPath[i], pattern, newPattern[i])}
```

For the maker_exec files, need to set to the following:   

#-----Location of Executables Used by MAKER/EVALUATOR   
makeblastdb=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/makeblastdb #location of NCBI+ makeblastdb executable   
blastn=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/blastn #location of NCBI+ blastn executable  
blastx=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/blastx #location of NCBI+ blastx executable   
tblastx=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/tblastx #location of NCBI+ tblastx executable   
formatdb=/opt/bio/ncbi/bin/formatdb #location of NCBI formatdb executable  
blastall=/opt/bio/ncbi/bin/blastall #location of NCBI blastall executable   
xdformat= #location of WUBLAST xdformat executable   
blasta= #location of WUBLAST blasta executable   
RepeatMasker=/home/CFIA-ACIA/girouxeml/RepeatMasker/RepeatMasker #location of RepeatMasker executable  
exonerate=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/exonerate #location of exonerate executable   
   
#-----Ab-initio Gene Prediction Algorithms   
snap=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/snap #location of snap executable  
gmhmme3=/home/CFIA-ACIA/girouxeml/prog/genemark-es/gmhmme3 #location of eukaryotic genemark executable   
gmhmmp= #location of prokaryotic genemark executable  
augustus=/home/CFIA-ACIA/girouxeml/prog/miniconda/pkgs/augustus-3.2.3-boost1.57_0/bin/augustus #location of augustus executable   
fgenesh= #location of fgenesh executable   
tRNAscan-SE=/home/CFIA-ACIA/girouxeml/prog/tRNAscan-SE/bin/tRNAscan-SE #location of trnascan executable  
snoscan=/home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/bin/snoscan #location of snoscan executable  
   
#-----Other Algorithms  
probuild=/home/CFIA-ACIA/girouxeml/prog/genemark-es/probuild #location of probuild executable (required for genemark)  

I'm using the repeatmasker installation in my ~/prog/RepeatMasker directory - not the install from conda. Install from
conda would require complete re-set up of RepBase for RepeatMasker.

#### 5-D. Run MAKER round 2.  
**Then we can run MAKER, substituting this new control file, and summarize the output, as we did before.**
```{r}
prefix <- "maker_round_2_run"
node   <- 4
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ", "cd ", maker_rnd2_path, " && maker ", #makerPath, 
                     " -base ", paste(SppAbbr, "_rnd2", sep = ""),
                     " ", paste(maker_rnd2_path, "maker_opts.ctl", sep = ""),
                     " ", paste(maker_rnd2_path, "maker_bopts.ctl", sep = ""),
                     " ", paste(maker_rnd2_path, "maker_exe.ctl", sep = ""),
                     " -cpus ", node,  
                     " && conda deactivate ", sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
# cd to the dir and run: 
# $ qsub -pe smp 4 -cwd -S /bin/bash maker_round2_run1.sub
# $ qsub -pe smp 4 -cwd -S /bin/bash maker_round2_run2.sub
# Preform the above qsub multiple times to have like a multithread run.
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

#### 5-E. Assemble the MAKER round 2 GFF and FASTA outputs.  
**We conclude by assembling together the GFF and FASTA outputs.**
```{r}
metadataAssemblies$makerRnd2_OutputPath <- paste(metadataAssemblies$maker_rnd2_path, 
                                                 metadataAssemblies$SppAbbr, "_rnd2.maker.output/", sep = "")
# GFF with the sequences:
prefix  <- "round2_mergeGFF3_maker"
cmd    <- with(metadataAssemblies,
               paste("cd ", makerRnd2_OutputPath, " && conda activate makerenv && gff3_merge -s -d ",
                     paste(makerRnd2_OutputPath, SppAbbr, "_rnd2_master_datastore_index.log", sep = ""),
                     " > ", paste(makerRnd2_OutputPath, SppAbbr, "_rnd2.all.maker.gff3", sep = ""),
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

# Collect all the fastas:
prefix2 <- "round2_fastaMerge_maker"
cmd2    <- with(metadataAssemblies,
                paste("cd ", makerRnd2_OutputPath, " && conda activate makerenv && fasta_merge -d ",
                      paste(makerRnd2_OutputPath, SppAbbr, "_rnd2_master_datastore_index.log", sep = ""),
                      " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)

# GFF without the sequences:
prefix3 <- "round2_mergeGFF3_maker_noseq"
cmd3    <- with(metadataAssemblies,
                paste("cd ", makerRnd2_OutputPath, " && conda activate makerenv && gff3_merge -n -s -d ",
                      paste(makerRnd2_OutputPath, SppAbbr, "_rnd2_master_datastore_index.log", sep = ""),
                      " > ", paste(makerRnd2_OutputPath, SppAbbr, "_rnd2.all.maker.noseq.gff3", sep = ""),
                     " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd3, prefix3, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix); RemoveQsubTempFiles(sharedPathAn, prefix2); RemoveQsubTempFiles(sharedPathAn, prefix3)
```


**Export confident gene models from round 1 of MAKER using maker2zff:**  
For determining which genes are High Confidence for Retraining:
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$maker_rnd2_path[k], "snap", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$snapMakerRnd2Path <- paste(metadataAssemblies$maker_rnd2_path, "snap/", sep = "")

for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$snapMakerRnd2Path[k], "round1", sep = ""), showWarnings = TRUE, recursive = FALSE)}
metadataAssemblies$snapRnd1MakerRnd2Path <- paste(metadataAssemblies$snapMakerRnd2Path, "round1/", sep = "")

prefix <- "round2_snapMaker2zff"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd2Path, " && conda activate makerenv && maker2zff -x 0.25 -l 50 -c 0 -e 0 -o 0 -d ", 
                     paste(makerRnd2_OutputPath, SppAbbr, "_rnd2_master_datastore_index.log", sep = ""), 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
**Take a quick look at number of sequences in the genome.dna file:**
```{r}
cmd <- with(metadataAssemblies, paste("cd ", snapRnd1MakerRnd2Path, " && ", 'grep ">" genome.dna | wc -l ', sep = ""))
sapply(cmd, function(x) system(x))

cmd <- with(metadataAssemblies, file.rename(paste(snapRnd1MakerRnd2Path, "genome.dna", sep = ""),
                                            paste(snapRnd1MakerRnd2Path, SppAbbr, "_rnd2.zff.dna", sep = "")))
sapply(cmd, function(x) system(x))

cmd <- with(metadataAssemblies, file.rename(paste(snapRnd1MakerRnd2Path, "genome.ann", sep = ""),
                                            paste(snapRnd1MakerRnd2Path, SppAbbr, "_rnd2.zff.ann", sep = "")))
sapply(cmd, function(x) system(x))
```

**Gather some stats and validate:**
```{r}
prefix  <- "round2_fathom_stats"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd2Path, " && conda activate makerenv && fathom ",
                     paste(SppAbbr, "_rnd2.zff.ann", sep = ""),
                     " ", paste(SppAbbr, "_rnd2.zff.dna", sep = ""),
                     " -gene-stats > gene-stats.log 2>&1 ", 
                     " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

prefix2 <- "round2_fathom_validate"
cmd2    <- with(metadataAssemblies, 
                paste("cd ", snapRnd1MakerRnd2Path, " && conda activate makerenv && fathom ",
                      paste(SppAbbr, "_rnd2.zff.ann", sep = ""),
                      " ", paste(SppAbbr, "_rnd2.zff.dna", sep = ""),
                      " -validate > validate.log 2>&1 ", 
                      " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix); RemoveQsubTempFiles(sharedPathAn, prefix2)
```

**Collect the training sequences and annotations, plus 1000 surrounding bp for training**
```{r}
prefix <- "round2_fathom_categorize"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd2Path, " && conda activate makerenv && fathom ",
                     paste(SppAbbr, "_rnd2.zff.ann", sep = ""),
                     " ", paste(SppAbbr, "_rnd2.zff.dna", sep = ""),
                     " -categorize 1000 > categorize.log 2>&1 ", 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Wait for the categorize run to finish before doing the export, which is next.**
```{r}
prefix2 <- "round2_fathom_export"
cmd2    <- with(metadataAssemblies,
                paste("cd ", snapRnd1MakerRnd2Path, " && conda activate makerenv && fathom ",
                      " uni.ann uni.dna -export 1000 -plus > uni-plus.log 2>&1 ", 
                      " && conda deactivate ", sep = ""))
suffix  <- ".sub"; cat(bashDirections); MakeQsubs(cmd2, prefix2, suffix)
```
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix2)
```
**Create the training parameters for SNAP:**
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$snapRnd1MakerRnd2Path[k], "params", sep = ""),
               showWarnings = TRUE, recursive = FALSE)}

prefix <- "round2_forge"
cmd    <- with(metadataAssemblies,
               paste("cd ", paste(snapRnd1MakerRnd2Path, "params/", sep = ""), " && conda activate makerenv && forge ",
                     " ../export.ann ../export.dna > ../forge.log 2>&1 ", 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

**Assemble the HMM:**
```{r}
prefix <- "round2_hmmAssembler_Maker"
cmd    <- with(metadataAssemblies,
               paste("cd ", snapRnd1MakerRnd2Path, " && conda activate makerenv && hmm-assembler.pl ",
                     paste(SppAbbr, "_rnd2.zff", sep = ""),
                     " params > ", paste(SppAbbr, "_rnd2.zff.hmm", sep = ""), 
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
### We've now completed the 2nd round of MAKER.   
#### 5-F. Evaluate the gene models.  
We've now completed the 2nd round of MAKER and should evaluate the gene models we have so far:  

**i. Count the number of gene models and the gene lengths:**    
I manually recorded the output values to a summary BUSCO excel file. Welcome to ideas on how to capture the output.
```{r}
cmd <- with(metadataAssemblies, 
            paste("cd ", makerRnd2_OutputPath, " && ", " cat ", SppAbbr, "_rnd2.all.maker.gff3 ", 
                  " | awk '{ if ($3 ==", '"gene") print $0}', 
                  "' | awk '{ sum += ($5 - $4) } END { print NR, sum / NR }'", sep = ""))

sapply(cmd, function(x) system(x))
```
**ii. Visualize the AED distribution:**  
AED ranges from 0 to 1 and quantifies the confidence in a gene model 
based on empirical evidence. Basically, the lower the AED, the better a gene model is likely to be. Ideally, 
95% or more of the gene models will have an AED of 0.5 or better in the case of good assemblies. You can use 
this AED_cdf_generator.pl script to help with this.  
I have just recorded the fraction at 0.5 into my summary excel table. Open to ideas on how to capture it better. 
```{r}
cmd <- with(metadataAssemblies, 
            paste("cd ", makerRnd2_OutputPath, " && ", " perl ", aedCDFgenePath, 
                  " -b 0.025 ", SppAbbr, "_rnd2.all.maker.gff3", sep = "")) 
sapply(cmd, function(x) system(x))
```
**iii. Run BUSCO using the Augustus species HMM to look at the results:**  
We can run BUSCO using the Augustus species HMM we obtained, without having to train Augustus. Only include the 
transcript sequences, and not the 1000 bp on each side, and be sure to take the best (i.e., longest) transcript for
each gene so we aren't artificially seeding duplicates. We could also run it on the best protein sequence per gene
instead. 
```{r}
prefix <- "round2_eval_with_Busco"
node   <- 15
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && cd ", makerRnd2_OutputPath, " && python ", 
                     buscoPath, " -i ", paste(SppAbbr, "_rnd2.all.maker.transcripts.fasta", sep = ""),
                     " -o annotation_eval ", " -c ", node,
                     " -l ", buscoStrpDataSet, " -m transcriptome -sp ", ScientificName, " -z --augustus_parameters='--progress=true'",
                     # " --restart ", 
                     # " --force ",
                     " && conda deactivate ",
                     sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
# Note, if the run fails, restart the run with the following "--restart", it will continue from where it left off. However, check the 
# config.ini file in ~/prog/busco/config/ to make sure that restart is set to True, and that you adjust to the correct cpus number.
```
BUSCO was run in mode: transcriptome   
Phra1:   
Results:   
C:79.9%[S:79.9%,D:0.0%],F:2.1%,M:18.0%,n:234   
187 Complete BUSCOs (C)   
187 Complete and single-copy BUSCOs (S)   
0 Complete and duplicated BUSCOs (D)   
5 Fragmented BUSCOs (F)   
42 Missing BUSCOs (M)   
234 Total BUSCO groups searched   

BUSCO was run in mode: transcriptome   
Phra2:   
Results:   
C:85.0%[S:85.0%,D:0.0%],F:1.7%,M:13.3%,n:234   
199 Complete BUSCOs (C)   
199 Complete and single-copy BUSCOs (S)   
0 Complete and duplicated BUSCOs (D)   
4 Fragmented BUSCOs (F)   
31 Missing BUSCOs (M)   
234 Total BUSCO groups searched   

### 6. Training Augustus - Round 2  
We won't be using BUSCO to train Augustus the second time since as there is a bias in the models it
produces for conserved genes that tend to be short and intron poor. To avoid this bias in the second round, we use a broad selection 
of gene models instead. After using the maker2zff script and then fathom to generate the export.ann and export.dna files, we will use 
a script that converts the zff files to GenBank format to train Augustus using the zff2augustus_gbk.pl script available at:  
https://github.com/hyphaltip/genome-scripts/blob/master/gene_prediction/zff2augustus_gbk.pl.  
  
#### 6-A. Set up the training directories:
```{r}
for(k in 1:nrow(metadataAssemblies)){
    dir.create(paste(metadataAssemblies$maker_rnd2_path[k], "rnd2_Augustus_Training", sep = ""), showWarnings = TRUE, recursive = FALSE)}

metadataAssemblies$rnd2_AugTrain <- paste(metadataAssemblies$maker_rnd2_path, "rnd2_Augustus_Training/", sep = "")
```

#### 6-B. Convert the zff files to GenBank format to prepare for Augustus training:
```{r}
prefix <- "round2_Augustus_zff2gbk"

cmd    <- with(metadataAssemblies, 
               paste("cd ", rnd2_AugTrain, " && ", zff2augGbkPath, 
                     " ", paste(snapRnd1MakerRnd2Path, "export.ann", sep = ""),
                     " ", paste(snapRnd1MakerRnd2Path, "export.dna", sep = ""),
                     " > ", SppAbbr, ".train.gb",
                     sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)

metadataAssemblies$rnd2AugTrainGB     <- paste(metadataAssemblies$SppAbbr, ".train.gb", sep = "")
metadataAssemblies$rnd2AugTrainGBpath <- paste(metadataAssemblies$rnd2_AugTrain, metadataAssemblies$rnd2AugTrainGB, sep = "")
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
Not sure of the following steps, so they are test and need to be reviewed. They follow the steps
outlined in https://vcru.wisc.edu/simonlab/bioinformatics/programs/augustus/docs/tutorial2015/training.html.  
  
#### 6-C Randomly split the set of annotated sequences in a training and a test set:  
In order for the test accuracy to be statistically meaningful the test set should also be large enough (100-200 genes). 
We need to split the set of gene structures really randomly! Do not just take the first and the last part of the file 
as then the test set is unlikely to be representative. We can achieve this with the randomSplit.pl script that comes
with the Augustus package. 
```{r}
prefix <- "round2_Aug_randomSplit"
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", rnd2_AugTrain, " && ", "randomSplit.pl ", rnd2AugTrainGB, " 100 ",
                     " && conda deactivate ", sep = ""))

suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
#### 6-D. Set up the meta parameters file and create the species training files.  
**Make a meta parameters file for our species.**  
We call parameters like the size of the window of the splice site models and the order of the Markov model 
meta parameters, in contrast to parameters like the distribution of splice site patterns, the k-mer probabilities 
of coding and noncoding regions. There are a few dozen meta parameters but many thousands of parameters. The meta 
parameters determine how the parameters are calculated. 
  
**Create the files for training our species from a template:**  
new_species.pl uses the environment variable AUGUSTUS_CONFIG_PATH to determine the directory in which 
AUGUSTUS stores the species parameters.
```{r}
prefix <- "round2_AugTrainingFiles"
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", rnd2_AugTrain, " && new_species.pl ",
                     " --species=", SppAbbr, "_AugRnd2",
                     " --AUGUSTUS_CONFIG_PATH=/isilon/cfia-ottawa-fallowfield/users/girouxeml/prog/augustus/config",
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```

**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
#### 6-E. Perform an inital training run.  
We will use the training set of gene structures, genes.train.gb, to train Augustus for our species. Etraining will create/update
parameter files for exon, intron, and intergenic regions in the $AUGUSTUS_CONFIG_PATH/species/ourSpecies.
```{r}
prefix <- "round2_AugEtraining"
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", rnd2_AugTrain, " && etraining ",
                     " --species=", SppAbbr, "_AugRnd2 ", rnd2AugTrainGB,
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
# Read in 3174 genbank sequences.
Quantiles of the GC contents in the training set:
0%      0.441
5%      0.501   10%     0.512
15%     0.518   20%     0.524
25%     0.529   30%     0.533
35%     0.536   40%     0.54
45%     0.544   50%     0.547
55%     0.55    60%     0.554
65%     0.557   70%     0.56
75%     0.564   80%     0.569
85%     0.573   90%     0.578
95%     0.586   100%    0.628
HMM-training the parameters...
i= 0 bc= (0.237, 0.263, 0.263, 0.237)
 ** building model for exons *EXON*
start codon frequencies: ATG(3174)
# admissible start codons and their probabilities: ATG(1), CTG(0), TTG(0)
 number of bases in the reading frames: 1715569 1718287 1718419
--- frame = 0 ---    minPatSum = 233
--- frame = 1 ---    minPatSum = 233
--- frame = 2 ---    minPatSum = 233
--- initial frame = 0 ---    minPatSum = 233
--- initial frame = 1 ---    minPatSum = 233
--- initial frame = 2 ---    minPatSum = 233
--- internal exon terminal frame = 0 ---    minPatSum = 233
--- internal exon terminal frame = 1 ---    minPatSum = 233
--- internal exon terminal frame = 2 ---    minPatSum = 233
single, initial, internal, terminal mean exon lengths :
201     301     251     530
single exon : 1
initial exon 0 : 1438
initial exon 1 : 876
initial exon 2 : 859
internal exon 0 : 2926
internal exon 1 : 1353
internal exon 2 : 1482
terminal exon : 3173
Frequency of stop codons:
tag: 1171 (0.369)
taa: 1102 (0.347)
tga:  901 (0.284)
end *EXON*
Storing parameters to file...
Writing exon model parameters [1] to file /home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/config/species/Phra1_AugRnd2/Phra1_AugRnd2_exon_probs.pbl.
# Read in 3250 genbank sequences.
Quantiles of the GC contents in the training set:
0%      0.42
5%      0.501   10%     0.512
15%     0.519   20%     0.525
25%     0.53    30%     0.534
35%     0.537   40%     0.542
45%     0.546   50%     0.549
55%     0.552   60%     0.556
65%     0.559   70%     0.563
75%     0.567   80%     0.571
85%     0.575   90%     0.582
95%     0.59    100%    0.637
HMM-training the parameters...
i= 0 bc= (0.237, 0.263, 0.263, 0.237)
 ** building model for exons *EXON*
start codon frequencies: ATG(3250)
# admissible start codons and their probabilities: ATG(1), CTG(0), TTG(0)
 number of bases in the reading frames: 1731707 1734475 1734604
--- frame = 0 ---    minPatSum = 233
--- frame = 1 ---    minPatSum = 233
--- frame = 2 ---    minPatSum = 233
--- initial frame = 0 ---    minPatSum = 233
--- initial frame = 1 ---    minPatSum = 233
--- initial frame = 2 ---    minPatSum = 233
--- internal exon terminal frame = 0 ---    minPatSum = 233
--- internal exon terminal frame = 1 ---    minPatSum = 233
--- internal exon terminal frame = 2 ---    minPatSum = 233
single, initial, internal, terminal mean exon lengths :
846     294     252     525
single exon : 1
initial exon 0 : 1496
initial exon 1 : 906
initial exon 2 : 847
internal exon 0 : 2918
internal exon 1 : 1333
internal exon 2 : 1459
terminal exon : 3249
Frequency of stop codons:
tag: 1159 (0.357)
taa: 1148 (0.353)
tga:  943 (0.29)
end *EXON*
Storing parameters to file...
Writing exon model parameters [1] to file /home/CFIA-ACIA/girouxeml/prog/miniconda/envs/makerenv/config/species/Phra2_AugRnd2/Phra2_AugRnd2_exon_probs.pbl.
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```
#### 6-F. Test the prediction accuracy of the newly-created Augustus training files.  
We can test the prediction accuracy of our new Augustus training files on the test set we generated when we used
randomSplit.pl.
```{r}
prefix <- "round2_AugTrain_InitTest"
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", rnd2_AugTrain, " && augustus ", " --species=", SppAbbr, "_AugRnd2 ",
                     rnd2AugTrainGB, ".test  2>&1 | tee firsttest.out",
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix)
```
**Checking the Evaluation Results.**  
You can see the evaluation summary in the firsttest.out file by typing the following in the command line:  
  
**_$ grep -A 22 Evaluation firsttest.out_**  
  
You should see an output like the following:  
Phra1:   
*******      Evaluation of gene prediction     *******

---------------------------------------------\
                 | sensitivity | specificity |
---------------------------------------------|
nucleotide level |       0.958 |       0.797 |
---------------------------------------------/

----------------------------------------------------------------------------------------------------------\
           |  #pred |  #anno |      |    FP = false pos. |    FN = false neg. |             |             |
           | total/ | total/ |   TP |--------------------|--------------------| sensitivity | specificity |
           | unique | unique |      | part | ovlp | wrng | part | ovlp | wrng |             |             |
----------------------------------------------------------------------------------------------------------|
           |        |        |      |                194 |                137 |             |             |
exon level |    478 |    421 |  284 | ------------------ | ------------------ |       0.675 |       0.594 |
           |    478 |    421 |      |   87 |   11 |   96 |   84 |   17 |   36 |             |             |
----------------------------------------------------------------------------------------------------------/

----------------------------------------------------------------------------\
transcript | #pred | #anno |   TP |   FP |   FN | sensitivity | specificity |
----------------------------------------------------------------------------|
gene level |   159 |   100 |   38 |  121 |   62 |        0.38 |       0.239 |
----------------------------------------------------------------------------/
   
Phra2:   
*******      Evaluation of gene prediction     *******

---------------------------------------------\
                 | sensitivity | specificity |
---------------------------------------------|
nucleotide level |       0.951 |       0.859 |
---------------------------------------------/

----------------------------------------------------------------------------------------------------------\
           |  #pred |  #anno |      |    FP = false pos. |    FN = false neg. |             |             |
           | total/ | total/ |   TP |--------------------|--------------------| sensitivity | specificity |
           | unique | unique |      | part | ovlp | wrng | part | ovlp | wrng |             |             |
----------------------------------------------------------------------------------------------------------|
           |        |        |      |                170 |                130 |             |             |
exon level |    381 |    341 |  211 | ------------------ | ------------------ |       0.619 |       0.554 |
           |    381 |    341 |      |   87 |   13 |   70 |   86 |   11 |   33 |             |             |
----------------------------------------------------------------------------------------------------------/

----------------------------------------------------------------------------\
transcript | #pred | #anno |   TP |   FP |   FN | sensitivity | specificity |
----------------------------------------------------------------------------|
gene level |   148 |   100 |   37 |  111 |   63 |        0.37 |        0.25 |
----------------------------------------------------------------------------/
**To remove the output files after you are done:**
```{r}
RemoveQsubTempFiles(sharedPathAn, prefix)
```

#### 6-G. Optimize the Augustus prediction accuracy.  
We can optimize the Augustus prediction accuracy by running the optimize_augustus.pl script that comes with the Augustus
package. This script adjusts the meta parameters in the *_parameters.cfg file. Note that this script will alternatingly
use augustus and etraining programs, and may take a long time to complete. It can increase the prediction accuracy by
a few percentage points.  
```{r}
prefix <- "round2_AugTrain_Optimize_cpus12"
node   <- 12
cmd    <- with(metadataAssemblies,
               paste("conda activate makerenv && ",
                     "cd ", rnd2_AugTrain, " && optimize_augustus.pl", " --cpus=", node, 
                     " --species=", SppAbbr, "_AugRnd2 ", rnd2AugTrainGB, ".train",
                     " && conda deactivate ", sep = ""))
suffix <- ".sub"; cat(bashDirections); MakeQsubs(cmd, prefix, suffix, node)
```
If you want to see how the improvements from training are coming along, you can use awk onthe file:  
[CFIA-ACIA+girouxeml@biocomp-0-2 round2_AugTrain_Optimize_cpus12]$ awk '/starting accuracy:|found improvement/ { print }' round2_AugTrain_Optimize_cpus121.sub.o286580

Bowtie2:
Creating Bowtie reference index from the fasta file:
```{r bowind eval = FALSE, echo = FALSE, include = FALSE, cache=TRUE}
bowind <- "phraRef"
cmd    <- paste("gunzip ", phraRefFna, ".gz",  " && ",  bowtie2BuildPath, 
                " -f ", phraRefFna, " ", paste(pathFastq, bowind, sep = ""), sep = "")
cmd
system(cmd)
```

Bowtie2 alignment:
```{r}

bowtie2Path <- "/opt/bio/bowtie2/bowtie2"
bowtie2AlignPath <- "/opt/bio/bowtie2/bowtie2-align"

cmd <- with(metadataAssembly, 
            paste(bowtie2Path, " -x ", paste(pathFastq, bowind, sep = ""), 
                  ))


```

















